import { use, insert, memo, createComponent, Portal, mergeProps, template, effect, className, style, spread, setAttribute } from 'solid-js/web';
import { ComponentUtil, GridCoreCreator, BaseComponentWrapper, VanillaFrameworkOverrides, CtrlsService, ColumnApi, GridCtrl, GroupCellRendererCtrl, _, GridBodyCtrl, RowContainerName, TabGuardCtrl, TabGuardClassNames, GridHeaderCtrl, getRowContainerTypeForName, RowContainerCtrl, HeaderRowContainerCtrl, CssClassManager, HeaderRowType, AgPromise, PopupEditorWrapper } from 'ag-grid-community';
import { createContext, createSignal, onCleanup, createEffect, onMount, For, createMemo, useContext } from 'solid-js';

// src/grid/agGridSolid.tsx

// src/grid/core/solidCompWrapper.tsx
var SolidCompWrapper = class {
  constructor(SolidCompClass, portalManager) {
    this.SolidCompClass = SolidCompClass;
    this.portalManager = portalManager;
  }
  init(props) {
    this.eGui = document.createElement("div");
    this.eGui.className = "ag-solid-container";
    this.portalInfo = {
      mount: this.eGui,
      SolidClass: this.SolidCompClass,
      props,
      ref: (instance) => {
        this.instance = instance;
      }
    };
    this.portalManager.addPortal(this.portalInfo);
  }
  destroy() {
    this.portalInfo && this.portalManager.removePortal(this.portalInfo);
  }
  getGui() {
    return this.eGui;
  }
  hasMethod(name) {
    return this.instance[name] != null;
  }
  getFrameworkComponentInstance() {
    return this.instance;
  }
  callMethod(name, args) {
    return this.instance[name].apply(this.instance, args);
  }
  addMethod(name, callback) {
    this[name] = callback;
  }
};

// src/grid/core/solidCompWrapperFactory.tsx
var SolidCompWrapperFactory = class extends BaseComponentWrapper {
  constructor(portalManager) {
    super();
    this.portalManager = portalManager;
  }
  createWrapper(SolidComponentClass) {
    return new SolidCompWrapper(SolidComponentClass, this.portalManager);
  }
};
var BeansContext = createContext({});

// src/grid/core/utils.tsx
var classesList = (...list) => {
  const filtered = list.filter((s) => s != null && s !== "");
  return filtered.join(" ");
};
var CssClasses = class _CssClasses {
  classesMap = {};
  constructor(...initialClasses) {
    initialClasses.forEach((className) => {
      this.classesMap[className] = true;
    });
  }
  setClass(className, on) {
    const nothingHasChanged = !!this.classesMap[className] == on;
    if (nothingHasChanged) {
      return this;
    }
    const res = new _CssClasses();
    res.classesMap = {
      ...this.classesMap
    };
    res.classesMap[className] = on;
    return res;
  }
  toString() {
    const res = Object.keys(this.classesMap).filter((key) => this.classesMap[key]).join(" ");
    return res;
  }
};

// src/grid/cellRenderer/detailCellRenderer.tsx
var _tmpl$ = /* @__PURE__ */ template(`<div>`);
var DetailCellRenderer = (props) => {
  const {
    ctrlsFactory,
    context,
    gridOptionsService,
    resizeObserverService,
    clientSideRowModel,
    serverSideRowModel
  } = useContext(BeansContext);
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getGridCssClasses, setGridCssClasses] = createSignal(new CssClasses());
  const [getDetailGridOptions, setDetailGridOptions] = createSignal();
  const [getDetailRowData, setDetailRowData] = createSignal();
  let ctrl;
  let eGuiRef;
  const getCssClassesStr = createMemo(() => getCssClasses().toString() + " ag-details-row");
  const getGridCssClassesStr = createMemo(() => getGridCssClasses().toString() + " ag-details-grid");
  props.ref(() => ({
    // force new instance when grid tries to refresh
    refresh() {
      return ctrl.refresh();
    }
  }));
  onMount(() => {
    if (props.template && typeof props.template === "string") ;
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      addOrRemoveDetailGridCssClass: (name, on) => setGridCssClasses(getGridCssClasses().setClass(name, on)),
      setDetailGrid: (gridOptions) => setDetailGridOptions(gridOptions),
      setRowData: (rowData) => setDetailRowData(rowData),
      getGui: () => eGuiRef
    };
    ctrl = ctrlsFactory.getInstance("detailCellRenderer");
    if (!ctrl) {
      return;
    }
    context.createBean(ctrl);
    ctrl.init(compProxy, props);
    let resizeObserverDestroyFunc;
    if (gridOptionsService.get("detailRowAutoHeight")) {
      const checkRowSizeFunc = () => {
        if (eGuiRef == null) {
          return;
        }
        const clientHeight = eGuiRef.clientHeight;
        if (clientHeight != null && clientHeight > 0) {
          const updateRowHeightFunc = () => {
            props.node.setRowHeight(clientHeight);
            if (clientSideRowModel) {
              clientSideRowModel.onRowHeightChanged();
            } else if (serverSideRowModel) {
              serverSideRowModel.onRowHeightChanged();
            }
          };
          setTimeout(updateRowHeightFunc, 0);
        }
      };
      resizeObserverDestroyFunc = resizeObserverService.observeResize(eGuiRef, checkRowSizeFunc);
      checkRowSizeFunc();
    }
    return () => {
      context.destroyBean(ctrl);
      if (resizeObserverDestroyFunc) {
        resizeObserverDestroyFunc();
      }
    };
  });
  const setRef = (ref) => {
    ctrl.registerDetailWithMaster(ref.api, ref.columnApi);
  };
  return (() => {
    var _el$ = _tmpl$();
    var _ref$ = eGuiRef;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGuiRef = _el$;
    insert(_el$, (() => {
      var _c$ = memo(() => !!getDetailGridOptions());
      return () => _c$() && createComponent(agGridSolid_default, mergeProps({
        get ["class"]() {
          return getGridCssClassesStr();
        }
      }, getDetailGridOptions, {
        get rowData() {
          return getDetailRowData();
        },
        ref: setRef
      }));
    })());
    effect(() => className(_el$, getCssClassesStr()));
    return _el$;
  })();
};
var detailCellRenderer_default = DetailCellRenderer;
var JsUserComp = (p) => {
  const {
    context
  } = useContext(BeansContext);
  const promise = p.compDetails.newAgStackInstance();
  if (!promise) {
    return [];
  }
  const comp = promise.resolveNow(null, (x) => x);
  if (!comp) {
    return [];
  }
  p.ref && p.ref(comp);
  const gui = comp.getGui();
  onCleanup(() => {
    comp && context.destroyBean(comp);
    p.ref && p.ref(void 0);
  });
  return gui;
};
var jsUserComp_default = JsUserComp;
var SolidUserComp = (props) => {
  const SolidClass = props.compDetails.componentClass;
  let refSet = false;
  const setRef = (ref) => {
    if (!props.ref) {
      return;
    }
    props.ref(ref);
    refSet = true;
  };
  onCleanup(() => {
    if (refSet) {
      props.ref && props.ref(void 0);
    }
  });
  return createComponent(SolidClass, mergeProps({
    ref: setRef
  }, () => props.compDetails.params));
};
var solidUserComp_default = SolidUserComp;

// src/grid/userComps/userComp.tsx
var UserComp = (p) => {
  const showSolidComp = createMemo(() => {
    const details = p.compDetails;
    if (!details) {
      return false;
    }
    return details.componentFromFramework;
  });
  const showJsComp = createMemo(() => {
    const details = p.compDetails;
    if (!details) {
      return false;
    }
    return !details.componentFromFramework;
  });
  return [memo(() => memo(() => !!showSolidComp())() && createComponent(solidUserComp_default, {
    get compDetails() {
      return p.compDetails;
    },
    ref(r$) {
      var _ref$ = p.ref;
      typeof _ref$ === "function" ? _ref$(r$) : p.ref = r$;
    }
  })), memo(() => memo(() => !!showJsComp())() && createComponent(jsUserComp_default, {
    get compDetails() {
      return p.compDetails;
    },
    ref(r$) {
      var _ref$2 = p.ref;
      typeof _ref$2 === "function" ? _ref$2(r$) : p.ref = r$;
    }
  }))];
};
var userComp_default = UserComp;

// src/grid/cellRenderer/groupCellRenderer.tsx
var _tmpl$2 = /* @__PURE__ */ template(`<span><span></span><span></span><span></span><span class=ag-group-value></span><span class=ag-group-child-count>`);
var GroupCellRenderer = (props) => {
  const context = useContext(BeansContext).context;
  let eGui;
  let eValueRef;
  let eCheckboxRef;
  let eExpandedRef;
  let eContractedRef;
  let role = "gridcell";
  const [getInnerCompDetails, setInnerCompDetails] = createSignal();
  const [getChildCount, setChildCount] = createSignal();
  const [getValue, setValue] = createSignal();
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getExpandedCssClasses, setExpandedCssClasses] = createSignal(new CssClasses("ag-hidden"));
  const [getContractedCssClasses, setContractedCssClasses] = createSignal(new CssClasses("ag-hidden"));
  const [getCheckboxCssClasses, setCheckboxCssClasses] = createSignal(new CssClasses("ag-invisible"));
  props.ref(() => ({
    // force new instance when grid tries to refresh
    refresh() {
      return false;
    }
  }));
  onMount(() => {
    const compProxy = {
      setInnerRenderer: (details, valueToDisplay) => {
        setInnerCompDetails(details);
        const escapedValue = _.escapeString(valueToDisplay, true);
        setValue(escapedValue);
      },
      setChildCount: (count) => setChildCount(count),
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setContractedDisplayed: (displayed) => setContractedCssClasses(getContractedCssClasses().setClass("ag-hidden", !displayed)),
      setExpandedDisplayed: (displayed) => setExpandedCssClasses(getExpandedCssClasses().setClass("ag-hidden", !displayed)),
      setCheckboxVisible: (visible) => setCheckboxCssClasses(getCheckboxCssClasses().setClass("ag-invisible", !visible))
    };
    const ctrl = context.createBean(new GroupCellRendererCtrl());
    ctrl.init(compProxy, eGui, eCheckboxRef, eExpandedRef, eContractedRef, GroupCellRenderer, props);
    eGui.setAttribute("role", ctrl.getCellAriaRole());
    role = ctrl.getCellAriaRole();
    return () => {
      context.destroyBean(ctrl);
    };
  });
  const getClassName = createMemo(() => `ag-cell-wrapper ${getCssClasses().toString()}`);
  const getExpandedClassName = createMemo(() => `ag-group-expanded ${getExpandedCssClasses().toString()}`);
  const getContractedClassName = createMemo(() => `ag-group-contracted ${getContractedCssClasses().toString()}`);
  const getCheckboxClassName = createMemo(() => `ag-group-checkbox ${getCheckboxCssClasses().toString()}`);
  const isShowUserComp = () => getInnerCompDetails() != null;
  const isShowValue = () => getInnerCompDetails() == null && getValue() != null;
  return (() => {
    var _el$ = _tmpl$2(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.nextSibling, _el$5 = _el$4.nextSibling, _el$6 = _el$5.nextSibling;
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    spread(_el$, mergeProps({
      get ["class"]() {
        return getClassName();
      }
    }, () => !props.colDef ? {
      role
    } : {}), false, true);
    var _ref$2 = eExpandedRef;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eExpandedRef = _el$2;
    var _ref$3 = eContractedRef;
    typeof _ref$3 === "function" ? use(_ref$3, _el$3) : eContractedRef = _el$3;
    var _ref$4 = eCheckboxRef;
    typeof _ref$4 === "function" ? use(_ref$4, _el$4) : eCheckboxRef = _el$4;
    var _ref$5 = eValueRef;
    typeof _ref$5 === "function" ? use(_ref$5, _el$5) : eValueRef = _el$5;
    insert(_el$5, (() => {
      var _c$ = memo(() => !!isShowUserComp());
      return () => _c$() && createComponent(userComp_default, {
        get compDetails() {
          return getInnerCompDetails();
        }
      });
    })(), null);
    insert(_el$5, (() => {
      var _c$2 = memo(() => !!isShowValue());
      return () => _c$2() && memo(getValue);
    })(), null);
    insert(_el$6, getChildCount);
    effect((_p$) => {
      var _v$ = getExpandedClassName(), _v$2 = getContractedClassName(), _v$3 = getCheckboxClassName();
      _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$3, _p$.t = _v$2);
      _v$3 !== _p$.a && className(_el$4, _p$.a = _v$3);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$;
  })();
};
var groupCellRenderer_default = GroupCellRenderer;

// src/grid/core/solidFrameworkOverrides.tsx
var SolidFrameworkOverrides = class extends VanillaFrameworkOverrides {
  constructor() {
    super("solid");
  }
  frameworkComponents = {
    agGroupCellRenderer: groupCellRenderer_default,
    agGroupRowRenderer: groupCellRenderer_default,
    agDetailCellRenderer: detailCellRenderer_default
  };
  frameworkComponent(name) {
    return this.frameworkComponents[name];
  }
  isFrameworkComponent(comp) {
    if (!comp) {
      return false;
    }
    const prototype = comp.prototype;
    const isJsComp = prototype && "getGui" in prototype;
    return !isJsComp;
  }
};
var _tmpl$3 = /* @__PURE__ */ template(`<div class=ag-header-cell role=columnheader><div class=ag-header-cell-resize role=presentation></div><div class=ag-header-cell-comp-wrapper role=presentation>`);
var HeaderCellComp = (props) => {
  const {
    ctrl
  } = props;
  const [getWidth, setWidth] = createSignal();
  const [getColId, setColId] = createSignal(ctrl.getColId());
  const [getAriaSort, setAriaSort] = createSignal();
  const [getUserCompDetails, setUserCompDetails] = createSignal();
  let eGui;
  let eResize;
  let eHeaderCompWrapper;
  let userComp;
  const setRef = (ref) => {
    userComp = ref;
  };
  const cssClassManager = new CssClassManager(() => eGui);
  onMount(() => {
    const compProxy = {
      setWidth: (width) => setWidth(width),
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setAriaSort: (sort) => setAriaSort(sort),
      setUserCompDetails: (compDetails) => setUserCompDetails(compDetails),
      getUserCompInstance: () => userComp
    };
    ctrl.setComp(compProxy, eGui, eResize, eHeaderCompWrapper);
    const selectAllGui = ctrl.getSelectAllGui();
    eResize.insertAdjacentElement("afterend", selectAllGui);
    ctrl.setDragSource(eGui);
  });
  const style$1 = createMemo(() => ({
    width: getWidth()
  }));
  return (() => {
    var _el$ = _tmpl$3(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    var _ref$2 = eResize;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eResize = _el$2;
    var _ref$3 = eHeaderCompWrapper;
    typeof _ref$3 === "function" ? use(_ref$3, _el$3) : eHeaderCompWrapper = _el$3;
    insert(_el$3, (() => {
      var _c$ = memo(() => !!getUserCompDetails());
      return () => _c$() && createComponent(userComp_default, {
        get compDetails() {
          return getUserCompDetails();
        },
        ref: setRef
      });
    })());
    effect((_p$) => {
      var _v$ = style$1(), _v$2 = getColId(), _v$3 = getAriaSort();
      _p$.e = style(_el$, _v$, _p$.e);
      _v$2 !== _p$.t && setAttribute(_el$, "col-id", _p$.t = _v$2);
      _v$3 !== _p$.a && setAttribute(_el$, "aria-sort", _p$.a = _v$3);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$;
  })();
};
var headerCellComp_default = HeaderCellComp;
var _tmpl$4 = /* @__PURE__ */ template(`<div role=gridcell><div role=presentation></div><div role=presentation><button type=button class="ag-button ag-floating-filter-button-button"tabindex=-1>`);
var HeaderFilterCellComp = (props) => {
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getCssBodyClasses, setBodyCssClasses] = createSignal(new CssClasses());
  const [getCssButtonWrapperClasses, setButtonWrapperCssClasses] = createSignal(new CssClasses());
  const [getButtonWrapperAriaHidden, setButtonWrapperAriaHidden] = createSignal("false");
  const [getWidth, setWidth] = createSignal();
  const [getUserCompDetails, setUserCompDetails] = createSignal();
  let eGui;
  let eFloatingFilterBody;
  let eButtonWrapper;
  let eButtonShowMainFilter;
  let alreadyResolved = false;
  let userCompResolve;
  let userCompPromise;
  onMount(() => {
    userCompPromise = new AgPromise((resolve) => {
      userCompResolve = resolve;
    });
  });
  const setRef = (value) => {
    if (alreadyResolved) {
      return;
    }
    if (value == null) {
      return;
    }
    userCompResolve && userCompResolve(value);
    alreadyResolved = true;
  };
  const {
    ctrl
  } = props;
  onMount(() => {
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses((prev) => prev.setClass(name, on)),
      addOrRemoveBodyCssClass: (name, on) => setBodyCssClasses((prev) => prev.setClass(name, on)),
      setButtonWrapperDisplayed: (displayed) => {
        setButtonWrapperCssClasses((prev) => prev.setClass("ag-hidden", !displayed));
        setButtonWrapperAriaHidden(!displayed ? "true" : "false");
      },
      setWidth: (width) => setWidth(width),
      setCompDetails: (compDetails) => setUserCompDetails(compDetails),
      getFloatingFilterComp: () => userCompPromise,
      setMenuIcon: (eIcon) => eButtonShowMainFilter.appendChild(eIcon)
    };
    ctrl.setComp(compProxy, eGui, eButtonShowMainFilter, eFloatingFilterBody);
  });
  const getStyle = createMemo(() => ({
    width: getWidth()
  }));
  const getCssClassesString = createMemo(() => "ag-header-cell ag-floating-filter " + getCssClasses().toString());
  const getBodyCssClassesString = createMemo(() => getCssBodyClasses().toString());
  const getButtonWrapperCssClassesString = createMemo(() => "ag-floating-filter-button " + getCssButtonWrapperClasses().toString());
  return (() => {
    var _el$ = _tmpl$4(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild;
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    var _ref$2 = eFloatingFilterBody;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eFloatingFilterBody = _el$2;
    insert(_el$2, (() => {
      var _c$ = memo(() => !!getUserCompDetails());
      return () => _c$() && createComponent(userComp_default, {
        get compDetails() {
          return getUserCompDetails();
        },
        ref: setRef
      });
    })());
    var _ref$3 = eButtonWrapper;
    typeof _ref$3 === "function" ? use(_ref$3, _el$3) : eButtonWrapper = _el$3;
    var _ref$4 = eButtonShowMainFilter;
    typeof _ref$4 === "function" ? use(_ref$4, _el$4) : eButtonShowMainFilter = _el$4;
    effect((_p$) => {
      var _v$ = getCssClassesString(), _v$2 = getStyle(), _v$3 = getBodyCssClassesString(), _v$4 = getButtonWrapperAriaHidden(), _v$5 = getButtonWrapperCssClassesString();
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _p$.t = style(_el$, _v$2, _p$.t);
      _v$3 !== _p$.a && className(_el$2, _p$.a = _v$3);
      _v$4 !== _p$.o && setAttribute(_el$3, "aria-hidden", _p$.o = _v$4);
      _v$5 !== _p$.i && className(_el$3, _p$.i = _v$5);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    });
    return _el$;
  })();
};
var headerFilterCellComp_default = HeaderFilterCellComp;
var _tmpl$5 = /* @__PURE__ */ template(`<div role=columnheader><div>`);
var HeaderGroupCellComp = (props) => {
  const {
    ctrl
  } = props;
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getCssResizableClasses, setResizableCssClasses] = createSignal(new CssClasses());
  const [getResizableAriaHidden, setResizableAriaHidden] = createSignal("false");
  const [getWidth, setWidth] = createSignal();
  const [getColId, setColId] = createSignal(ctrl.getColId());
  const [getAriaExpanded, setAriaExpanded] = createSignal();
  const [getUserCompDetails, setUserCompDetails] = createSignal();
  let eGui;
  let eResize;
  onMount(() => {
    const compProxy = {
      setWidth: (width) => setWidth(width),
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setUserCompDetails: (compDetails) => setUserCompDetails(compDetails),
      setResizableDisplayed: (displayed) => {
        setResizableCssClasses((prev) => prev.setClass("ag-hidden", !displayed));
        setResizableAriaHidden(!displayed ? "true" : "false");
      },
      setAriaExpanded: (expanded) => setAriaExpanded(expanded)
    };
    ctrl.setComp(compProxy, eGui, eResize);
  });
  createEffect(() => {
    const userCompDetails = getUserCompDetails();
    if (userCompDetails == null) {
      return;
    }
    ctrl.setDragSource(eGui);
  });
  const style$1 = createMemo(() => ({
    width: getWidth()
  }));
  const getClassName = createMemo(() => "ag-header-group-cell " + getCssClasses().toString());
  const getResizableClassName = createMemo(() => "ag-header-cell-resize " + getCssResizableClasses().toString());
  return (() => {
    var _el$ = _tmpl$5(), _el$2 = _el$.firstChild;
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    insert(_el$, (() => {
      var _c$ = memo(() => !!getUserCompDetails());
      return () => _c$() && createComponent(userComp_default, {
        get compDetails() {
          return getUserCompDetails();
        }
      });
    })(), _el$2);
    var _ref$2 = eResize;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eResize = _el$2;
    effect((_p$) => {
      var _v$ = getClassName(), _v$2 = style$1(), _v$3 = getColId(), _v$4 = getAriaExpanded(), _v$5 = getResizableAriaHidden(), _v$6 = getResizableClassName();
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _p$.t = style(_el$, _v$2, _p$.t);
      _v$3 !== _p$.a && setAttribute(_el$, "col-id", _p$.a = _v$3);
      _v$4 !== _p$.o && setAttribute(_el$, "aria-expanded", _p$.o = _v$4);
      _v$5 !== _p$.i && setAttribute(_el$2, "aria-hidden", _p$.i = _v$5);
      _v$6 !== _p$.n && className(_el$2, _p$.n = _v$6);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0,
      n: void 0
    });
    return _el$;
  })();
};
var headerGroupCellComp_default = HeaderGroupCellComp;

// src/grid/header/headerRowComp.tsx
var _tmpl$6 = /* @__PURE__ */ template(`<div role=row>`);
var HeaderRowComp = (props) => {
  const {
    gridOptionsService
  } = useContext(BeansContext);
  const {
    ctrl
  } = props;
  const [getHeight, setHeight] = createSignal();
  const [getTop, setTop] = createSignal();
  const [getWidth, setWidth] = createSignal();
  const [getAriaRowIndex, setAriaRowIndex] = createSignal(ctrl.getAriaRowIndex());
  const [getCellCtrls, setCellCtrls] = createSignal([]);
  let eGui;
  const setCellCtrlsMaintainOrder = (next) => {
    const prev = getCellCtrls();
    const isEnsureDomOrder = gridOptionsService.get("ensureDomOrder");
    const isPrintLayout = gridOptionsService.isDomLayout("print");
    if (isEnsureDomOrder || isPrintLayout) {
      return next;
    }
    const prevMap = _.mapById(prev, (c) => c.getInstanceId());
    const nextMap = _.mapById(next, (c) => c.getInstanceId());
    const oldCtrlsWeAreKeeping = prev.filter((c) => nextMap.has(c.getInstanceId()));
    const newCtrls = next.filter((c) => !prevMap.has(c.getInstanceId()));
    const nextOrderMaintained = [...oldCtrlsWeAreKeeping, ...newCtrls];
    setCellCtrls(nextOrderMaintained);
  };
  onMount(() => {
    const compProxy = {
      setHeight: (height) => setHeight(height),
      setTop: (top) => setTop(top),
      setHeaderCtrls: (ctrls) => setCellCtrlsMaintainOrder(ctrls),
      setWidth: (width) => setWidth(width)
    };
    ctrl.setComp(compProxy);
  });
  const style$1 = createMemo(() => ({
    height: getHeight(),
    top: getTop(),
    width: getWidth()
  }));
  const cssClasses = ctrl.getHeaderRowClass();
  const createCellJsx = (cellCtrl) => {
    switch (ctrl.getType()) {
      case HeaderRowType.COLUMN_GROUP:
        return createComponent(headerGroupCellComp_default, {
          ctrl: cellCtrl
        });
      case HeaderRowType.FLOATING_FILTER:
        return createComponent(headerFilterCellComp_default, {
          ctrl: cellCtrl
        });
      default:
        return createComponent(headerCellComp_default, {
          ctrl: cellCtrl
        });
    }
  };
  return (() => {
    var _el$ = _tmpl$6();
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    className(_el$, cssClasses);
    insert(_el$, createComponent(For, {
      get each() {
        return getCellCtrls();
      },
      children: (cellCtrl, i) => createCellJsx(cellCtrl)
    }));
    effect((_p$) => {
      var _v$ = style$1(), _v$2 = getAriaRowIndex();
      _p$.e = style(_el$, _v$, _p$.e);
      _v$2 !== _p$.t && setAttribute(_el$, "aria-rowindex", _p$.t = _v$2);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })();
};
var headerRowComp_default = HeaderRowComp;

// src/grid/header/headerRowContainerComp.tsx
var _tmpl$7 = /* @__PURE__ */ template(`<div role=rowgroup>`);
var _tmpl$22 = /* @__PURE__ */ template(`<div role=presentation><div class=ag-header-container role=rowgroup>`);
var HeaderRowContainerComp = (props) => {
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getAriaHidden, setAriaHidden] = createSignal(false);
  const [getCenterContainerWidth, setCenterContainerWidth] = createSignal();
  const [getPinnedContainerWidth, setPinnedContainerWidth] = createSignal();
  const [getHeaderRowCtrls, setHeaderRowCtrls] = createSignal([]);
  const {
    context
  } = useContext(BeansContext);
  let eGui;
  const pinnedLeft = props.pinned === "left";
  const pinnedRight = props.pinned === "right";
  const centre = !pinnedLeft && !pinnedRight;
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount(() => {
    const compProxy = {
      setDisplayed: (displayed) => {
        setCssClasses(getCssClasses().setClass("ag-hidden", !displayed));
        setAriaHidden(!displayed);
      },
      setCtrls: (ctrls) => setHeaderRowCtrls(ctrls),
      // centre only
      setCenterWidth: (width) => setCenterContainerWidth(width),
      setViewportScrollLeft: (left) => eGui.scrollLeft = left,
      // pinned only
      setPinnedContainerWidth: (width) => setPinnedContainerWidth(width)
    };
    const ctrl = context.createBean(new HeaderRowContainerCtrl(props.pinned));
    ctrl.setComp(compProxy, eGui);
    destroyFuncs.push(() => context.destroyBean(ctrl));
  });
  const getClassName = createMemo(() => getCssClasses().toString());
  const insertRowsJsx = () => createComponent(For, {
    get each() {
      return getHeaderRowCtrls();
    },
    children: (ctrl) => createComponent(headerRowComp_default, {
      ctrl
    })
  });
  const eCenterContainerStyle = createMemo(() => ({
    width: getCenterContainerWidth()
  }));
  const ePinnedStyle = createMemo(() => ({
    width: getPinnedContainerWidth(),
    "min-width": getPinnedContainerWidth(),
    "max-width": getPinnedContainerWidth()
  }));
  return [pinnedLeft && (() => {
    var _el$ = _tmpl$7();
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    insert(_el$, insertRowsJsx);
    effect((_p$) => {
      var _v$ = "ag-pinned-left-header " + getClassName(), _v$2 = getAriaHidden(), _v$3 = ePinnedStyle();
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && setAttribute(_el$, "aria-hidden", _p$.t = _v$2);
      _p$.a = style(_el$, _v$3, _p$.a);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$;
  })(), pinnedRight && (() => {
    var _el$2 = _tmpl$7();
    var _ref$2 = eGui;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eGui = _el$2;
    insert(_el$2, insertRowsJsx);
    effect((_p$) => {
      var _v$4 = "ag-pinned-right-header " + getClassName(), _v$5 = getAriaHidden(), _v$6 = ePinnedStyle();
      _v$4 !== _p$.e && className(_el$2, _p$.e = _v$4);
      _v$5 !== _p$.t && setAttribute(_el$2, "aria-hidden", _p$.t = _v$5);
      _p$.a = style(_el$2, _v$6, _p$.a);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$2;
  })(), centre && (() => {
    var _el$3 = _tmpl$22(), _el$4 = _el$3.firstChild;
    var _ref$3 = eGui;
    typeof _ref$3 === "function" ? use(_ref$3, _el$3) : eGui = _el$3;
    insert(_el$4, insertRowsJsx);
    effect((_p$) => {
      var _v$7 = "ag-header-viewport " + getClassName(), _v$8 = eCenterContainerStyle();
      _v$7 !== _p$.e && className(_el$3, _p$.e = _v$7);
      _p$.t = style(_el$4, _v$8, _p$.t);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$3;
  })()];
};
var headerRowContainerComp_default = HeaderRowContainerComp;

// src/grid/header/gridHeaderComp.tsx
var _tmpl$8 = /* @__PURE__ */ template(`<div role=presentation>`);
var GridHeaderComp = () => {
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getHeight, setHeight] = createSignal();
  const {
    context
  } = useContext(BeansContext);
  let eGui;
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount(() => {
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setHeightAndMinHeight: (height) => setHeight(height)
    };
    const ctrl = context.createBean(new GridHeaderCtrl());
    ctrl.setComp(compProxy, eGui, eGui);
    destroyFuncs.push(() => context.destroyBean(ctrl));
  });
  const className$1 = createMemo(() => {
    let res = getCssClasses().toString();
    return "ag-header " + res;
  });
  const style$1 = createMemo(() => ({
    height: getHeight(),
    "min-height": getHeight()
  }));
  return (() => {
    var _el$ = _tmpl$8();
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    insert(_el$, createComponent(headerRowContainerComp_default, {
      pinned: "left"
    }), null);
    insert(_el$, createComponent(headerRowContainerComp_default, {
      pinned: null
    }), null);
    insert(_el$, createComponent(headerRowContainerComp_default, {
      pinned: "right"
    }), null);
    effect((_p$) => {
      var _v$ = className$1(), _v$2 = style$1();
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _p$.t = style(_el$, _v$2, _p$.t);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })();
};
var gridHeaderComp_default = GridHeaderComp;
var PopupEditorComp = (props) => {
  const {
    context,
    popupService,
    localeService,
    gridOptionsService
  } = useContext(BeansContext);
  const {
    editDetails,
    cellCtrl,
    eParentCell
  } = props;
  const {
    compDetails
  } = editDetails;
  const useModelPopup = gridOptionsService.get("stopEditingWhenCellsLoseFocus");
  const wrapper = context.createBean(new PopupEditorWrapper(compDetails.params));
  const ePopupGui = wrapper.getGui();
  const positionParams = {
    column: cellCtrl.getColumn(),
    rowNode: cellCtrl.getRowNode(),
    type: "popupCellEditor",
    eventSource: eParentCell,
    ePopup: ePopupGui,
    position: editDetails.popupPosition,
    keepWithinBounds: true
  };
  const positionCallback = popupService.positionPopupByComponent.bind(popupService, positionParams);
  const translate = localeService.getLocaleTextFunc();
  const addPopupRes = popupService.addPopup({
    modal: useModelPopup,
    eChild: ePopupGui,
    closeOnEsc: true,
    closedCallback: () => {
      cellCtrl.onPopupEditorClosed();
    },
    anchorToElement: eParentCell,
    positionCallback,
    ariaLabel: translate("ariaLabelCellEditor", "Cell Editor")
  });
  const hideEditorPopup = addPopupRes ? addPopupRes.hideFunc : void 0;
  onCleanup(() => {
    if (hideEditorPopup != null) {
      hideEditorPopup();
    }
    context.destroyBean(wrapper);
  });
  return createComponent(Portal, {
    mount: ePopupGui,
    get children() {
      return props.children;
    }
  });
};
var popupEditorComp_default = PopupEditorComp;

// src/grid/cells/showEditDetails.tsx
var ShowEditDetails = (props) => {
  const getCompDetails = createMemo(() => props.editDetails.compDetails);
  const compDetails = props.editDetails.compDetails;
  if (!compDetails) {
    return [];
  }
  const inPopup = props.editDetails.popup;
  const eGui = props.eGuiFn();
  return [inPopup && createComponent(popupEditorComp_default, {
    get cellCtrl() {
      return props.cellCtrl;
    },
    eParentCell: eGui,
    get editDetails() {
      return props.editDetails;
    },
    get children() {
      return createComponent(userComp_default, {
        get compDetails() {
          return getCompDetails();
        },
        ref(r$) {
          var _ref$ = props.setPopupRef;
          typeof _ref$ === "function" ? _ref$(r$) : props.setPopupRef = r$;
        }
      });
    }
  }), !inPopup && createComponent(userComp_default, {
    get compDetails() {
      return getCompDetails();
    },
    ref(r$) {
      var _ref$2 = props.setInlineRef;
      typeof _ref$2 === "function" ? _ref$2(r$) : props.setInlineRef = r$;
    }
  })];
};
var showEditDetails_default = ShowEditDetails;
var _tmpl$9 = /* @__PURE__ */ template(`<span role=presentation class=ag-cell-value>`);
var ToolsComp = (props) => {
  const {
    context
  } = useContext(BeansContext);
  const CompWrapper = (innerProps) => {
    const comp = innerProps.createFn();
    if (!comp) {
      return [];
    }
    onCleanup(() => context.destroyBean(comp));
    return memo(() => comp.getGui());
  };
  return [memo(() => memo(() => !!props.includeSelection)() && createComponent(CompWrapper, {
    createFn: () => {
      const checkboxSelectionComp = props.cellCtrl.createSelectionCheckbox();
      props.setSelectionCheckboxId(checkboxSelectionComp.getCheckboxId());
      return checkboxSelectionComp;
    }
  })), memo(() => memo(() => !!props.includeDndSource)() && createComponent(CompWrapper, {
    createFn: () => props.cellCtrl.createDndSource()
  })), memo(() => memo(() => !!props.includeRowDrag)() && createComponent(CompWrapper, {
    createFn: () => props.cellCtrl.createRowDragComp()
  }))];
};
var ShowRenderDetails = (props) => {
  const getCompDetails = createMemo(() => props.showDetails.compDetails);
  const isNoCompDetails = createMemo(() => props.showDetails.compDetails == null);
  const valueForNoCellRenderer = () => {
    const value = props.showDetails.value;
    return value && value.toString ? value.toString() : value;
  };
  const bodyJsxFunc = () => [memo(() => memo(() => !!isNoCompDetails())() && memo(valueForNoCellRenderer)), memo(() => memo(() => !!getCompDetails())() && createComponent(userComp_default, {
    get compDetails() {
      return getCompDetails();
    },
    ref(r$) {
      var _ref$ = props.ref;
      typeof _ref$ === "function" ? _ref$(r$) : props.ref = r$;
    }
  }))];
  return [memo(() => memo(() => !!props.showTools)() && createComponent(ToolsComp, {
    get includeDndSource() {
      return props.includeDndSource;
    },
    get includeRowDrag() {
      return props.includeRowDrag;
    },
    get includeSelection() {
      return props.includeSelection;
    },
    get setSelectionCheckboxId() {
      return props.setSelectionCheckboxId;
    },
    get cellCtrl() {
      return props.cellCtrl;
    }
  })), memo(() => memo(() => !!props.showCellWrapper)() ? (() => {
    var _el$ = _tmpl$9();
    var _ref$2 = props.setECellValue;
    typeof _ref$2 === "function" ? use(_ref$2, _el$) : props.setECellValue = _el$;
    insert(_el$, bodyJsxFunc);
    effect(() => setAttribute(_el$, "id", `cell-${props.cellInstanceId}`));
    return _el$;
  })() : bodyJsxFunc())];
};
var showRenderDetails_default = ShowRenderDetails;

// src/grid/cells/cellComp.tsx
var _tmpl$10 = /* @__PURE__ */ template(`<div> `);
var _tmpl$23 = /* @__PURE__ */ template(`<div class=ag-cell-wrapper role=presentation>`);
var checkCellEditorDeprecations = (popup, cellEditor, cellCtrl) => {
  const col = cellCtrl.getColumn();
  if (!popup && cellEditor.isPopup && cellEditor.isPopup()) {
    `AG Grid: Found an issue in column ${col.getColId()}. If using SolidJS, specify an editor is a popup using colDef.cellEditorPopup=true. AG Grid SolidJS cannot depend on the editor component specifying if it's in a popup (via the isPopup() method on the editor), as SolidJS needs to know this information BEFORE the component is created.`;
    _.doOnce(() => void 0, "jsEditorComp-isPopup-" + cellCtrl.getColumn().getColId());
  }
  if (popup && cellEditor.getPopupPosition && cellEditor.getPopupPosition() != null) {
    `AG Grid: Found an issue in column ${col.getColId()}. If using SolidJS, specify an editor popup position using colDef.cellEditorPopupPosition=true. AG Grid SolidJS cannot depend on the editor component specifying it's position (via the getPopupPosition() method on the editor), as SolidJS needs to know this information BEFORE the component is created.`;
    _.doOnce(() => void 0, "jsEditorComp-getPopupPosition-" + cellCtrl.getColumn().getColId());
  }
};
var CellComp = (props) => {
  const {
    cellCtrl,
    printLayout,
    editingRow
  } = props;
  const [renderDetails, setRenderDetails] = createSignal();
  const [editDetails, setEditDetails] = createSignal();
  let renderCompVersion = 0;
  const [renderCompVersionList, setRenderCompVersionList] = createSignal([renderCompVersion]);
  const [userStyles, setUserStyles] = createSignal();
  const [tabIndex, setTabIndex] = createSignal(cellCtrl.getTabIndex());
  const [colId, setColId] = createSignal(cellCtrl.getColumnIdSanitised());
  const [selectionCheckboxId, setSelectionCheckboxId] = createSignal();
  const [includeSelection, setIncludeSelection] = createSignal(false);
  const [includeRowDrag, setIncludeRowDrag] = createSignal(false);
  const [includeDndSource, setIncludeDndSource] = createSignal(false);
  const forceWrapper = cellCtrl.isForceWrapper();
  let eCellWrapper;
  let eCellValue;
  const setECellValue = (val) => {
    eCellValue = val;
  };
  let eGui;
  let cellRenderer = null;
  let cellEditor = null;
  const setEditorRef = (popup, ref) => {
    cellEditor = ref;
    if (!cellEditor) {
      return;
    }
    checkCellEditorDeprecations(popup, cellEditor, cellCtrl);
    const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
    if (editingCancelledByUserComp) {
      setTimeout(() => {
        cellCtrl.stopEditing(true);
        cellCtrl.focusCell(true);
      });
    }
    const refAny = ref;
    if (refAny.afterGuiAttached) {
      setTimeout(() => refAny.afterGuiAttached(), 0);
    }
  };
  const setPopupEditorRef = (ref) => setEditorRef(true, ref);
  const setInlineEditorRef = (ref) => setEditorRef(false, ref);
  const cssClassManager = new CssClassManager(() => eGui);
  const showTools = createMemo(() => renderDetails() != null && (includeSelection() || includeDndSource() || includeRowDrag()));
  const showCellWrapper = createMemo(() => forceWrapper || showTools());
  const cellInstanceId = cellCtrl.getInstanceId();
  onMount(() => {
    if (!cellCtrl) {
      return;
    }
    const compProxy = {
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setUserStyles: (styles) => setUserStyles(styles),
      getFocusableElement: () => eGui,
      setIncludeSelection: (include) => setIncludeSelection(include),
      setIncludeRowDrag: (include) => setIncludeRowDrag(include),
      setIncludeDndSource: (include) => setIncludeDndSource(include),
      getCellEditor: () => cellEditor,
      getCellRenderer: () => cellRenderer ? cellRenderer : null,
      getParentOfValue: () => eCellValue ? eCellValue : eCellWrapper ? eCellWrapper : eGui,
      setRenderDetails: (compDetails, value, force) => {
        setRenderDetails({
          value,
          compDetails,
          force
        });
      },
      setEditDetails: (compDetails, popup, popupPosition) => {
        if (compDetails) {
          setEditDetails({
            compDetails,
            popup,
            popupPosition
          });
          if (!popup) {
            setRenderDetails(void 0);
          }
        } else {
          setEditDetails(void 0);
        }
      }
    };
    cellCtrl.setComp(compProxy, eGui, eCellWrapper, printLayout, editingRow);
  });
  createEffect(() => {
    const isEditing = !!editDetails();
    const isPopup = isEditing && !!editDetails()?.popup;
    cssClassManager.addOrRemoveCssClass("ag-cell-value", !showCellWrapper());
    cssClassManager.addOrRemoveCssClass("ag-cell-inline-editing", isEditing && !isPopup);
    cssClassManager.addOrRemoveCssClass("ag-cell-popup-editing", isEditing && isPopup);
    cssClassManager.addOrRemoveCssClass("ag-cell-not-inline-editing", !isEditing || isPopup);
    cellCtrl.getRowCtrl()?.setInlineEditingCss(isEditing);
  });
  let readyForRefresh = false;
  createEffect(() => {
    const details = renderDetails();
    const isJsCellRenderer = details != null && details.compDetails != null && !details.compDetails.componentFromFramework;
    if (!isJsCellRenderer) {
      readyForRefresh = false;
      return;
    }
    if (!readyForRefresh) {
      readyForRefresh = true;
      return;
    }
    if (!cellRenderer) {
      return;
    }
    const params = details.compDetails.params;
    const result = cellRenderer.refresh ? cellRenderer.refresh(params) : false;
    if (result != true) {
      renderCompVersion++;
      setRenderCompVersionList([renderCompVersion]);
    }
  });
  const eGuiFn = () => eGui;
  const bodyJsxFunc = () => [createComponent(For, {
    get each() {
      return renderCompVersionList();
    },
    children: () => memo(() => memo(() => !!renderDetails())() && createComponent(showRenderDetails_default, {
      get showDetails() {
        return renderDetails();
      },
      ref(r$) {
        var _ref$ = cellRenderer;
        typeof _ref$ === "function" ? _ref$(r$) : cellRenderer = r$;
      },
      cellInstanceId,
      get showCellWrapper() {
        return showCellWrapper();
      },
      cellCtrl,
      get includeDndSource() {
        return includeDndSource();
      },
      get includeRowDrag() {
        return includeRowDrag();
      },
      get includeSelection() {
        return includeSelection();
      },
      setSelectionCheckboxId,
      get showTools() {
        return showTools();
      },
      setECellValue
    }))
  }), memo(() => memo(() => !!editDetails())() && createComponent(showEditDetails_default, {
    get editDetails() {
      return editDetails();
    },
    cellCtrl,
    eGuiFn,
    setInlineRef: setInlineEditorRef,
    setPopupRef: setPopupEditorRef
  }))];
  return (() => {
    var _el$ = _tmpl$10(); _el$.firstChild;
    var _ref$2 = eGui;
    typeof _ref$2 === "function" ? use(_ref$2, _el$) : eGui = _el$;
    insert(_el$, (() => {
      var _c$ = memo(() => !!showCellWrapper());
      return () => _c$() ? (() => {
        var _el$3 = _tmpl$23();
        var _ref$3 = eCellWrapper;
        typeof _ref$3 === "function" ? use(_ref$3, _el$3) : eCellWrapper = _el$3;
        insert(_el$3, bodyJsxFunc);
        return _el$3;
      })() : bodyJsxFunc();
    })(), null);
    effect((_p$) => {
      var _v$ = userStyles(), _v$2 = tabIndex(), _v$3 = cellCtrl.getCellAriaRole(), _v$4 = colId();
      _p$.e = style(_el$, _v$, _p$.e);
      _v$2 !== _p$.t && setAttribute(_el$, "tabindex", _p$.t = _v$2);
      _v$3 !== _p$.a && setAttribute(_el$, "role", _p$.a = _v$3);
      _v$4 !== _p$.o && setAttribute(_el$, "col-id", _p$.o = _v$4);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0
    });
    return _el$;
  })();
};
var cellComp_default = CellComp;

// src/grid/rows/rowComp.tsx
var _tmpl$11 = /* @__PURE__ */ template(`<div role=row>`);
var maintainOrderOnColumns = (prev, next, domOrder) => {
  if (domOrder) {
    const res2 = {
      list: next,
      instanceIdMap: /* @__PURE__ */ new Map()
    };
    next.forEach((c) => res2.instanceIdMap.set(c.getInstanceId(), c));
    return res2;
  }
  const oldCellCtrls = [];
  const newCellCtrls = [];
  const newInstanceIdMap = /* @__PURE__ */ new Map();
  const tempMap = /* @__PURE__ */ new Map();
  next.forEach((c) => tempMap.set(c.getInstanceId(), c));
  prev.list.forEach((c) => {
    const instanceId = c.getInstanceId();
    if (tempMap.has(instanceId)) {
      oldCellCtrls.push(c);
      newInstanceIdMap.set(instanceId, c);
    }
  });
  next.forEach((c) => {
    const instanceId = c.getInstanceId();
    if (!prev.instanceIdMap.has(instanceId)) {
      newCellCtrls.push(c);
      newInstanceIdMap.set(instanceId, c);
    }
  });
  const res = {
    list: [...oldCellCtrls, ...newCellCtrls],
    instanceIdMap: newInstanceIdMap
  };
  return res;
};
var RowComp = (params) => {
  const {
    rowCtrl,
    containerType
  } = params;
  const [getRowIndex, setRowIndex] = createSignal();
  const [getRowId, setRowId] = createSignal();
  const [getRowBusinessKey, setRowBusinessKey] = createSignal();
  const [getTabIndex, setTabIndex] = createSignal(rowCtrl.getTabIndex());
  const [getUserStyles, setUserStyles] = createSignal();
  const [getCellCtrls, setCellCtrls] = createSignal({
    list: [],
    instanceIdMap: /* @__PURE__ */ new Map()
  });
  const [getFullWidthCompDetails, setFullWidthCompDetails] = createSignal();
  const [getDomOrder, setDomOrder] = createSignal(false);
  const [getTop, setTop] = createSignal(rowCtrl.getInitialRowTop(containerType));
  const [getTransform, setTransform] = createSignal(rowCtrl.getInitialTransform(containerType));
  let eGui;
  let fullWidthCompRef;
  const setFullWidthRef = (newRef) => {
    fullWidthCompRef = newRef;
  };
  createEffect(() => {
    const compDetails = getFullWidthCompDetails();
    if (!compDetails) {
      return;
    }
    let tryCount = 0;
    const trySetup = () => {
      const eChild = eGui.firstChild;
      if (eChild) {
        rowCtrl.setupDetailRowAutoHeight(eChild);
        return;
      }
      if (tryCount >= 10) {
        return;
      }
      tryCount++;
      setTimeout(trySetup, 0);
    };
    trySetup();
  });
  onMount(() => {
    if (!rowCtrl.isAlive()) {
      return;
    }
    const cssClassManager = new CssClassManager(() => eGui);
    const compProxy = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: (value) => setTop(value),
      setTransform: (value) => setTransform(value),
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setDomOrder: (domOrder) => setDomOrder(domOrder),
      setRowIndex: (value) => setRowIndex(value),
      setRowId: (value) => setRowId(value),
      setRowBusinessKey: (value) => setRowBusinessKey(value),
      setUserStyles: (styles) => setUserStyles(styles),
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (next) => setCellCtrls(maintainOrderOnColumns(getCellCtrls(), next, getDomOrder())),
      showFullWidth: (compDetails) => setFullWidthCompDetails(compDetails),
      getFullWidthCellRenderer: () => fullWidthCompRef,
      refreshFullWidth: (getUpdatedParams) => {
        if (!fullWidthCompRef || !fullWidthCompRef.refresh) {
          return false;
        }
        return fullWidthCompRef.refresh(getUpdatedParams());
      }
    };
    rowCtrl.setComp(compProxy, eGui, containerType);
    onCleanup(() => rowCtrl.unsetComp(containerType));
  });
  const getRowStyles = createMemo(() => {
    const res = {
      top: getTop(),
      transform: getTransform()
    };
    Object.assign(res, getUserStyles());
    return res;
  });
  const isShowCells = createMemo(() => getCellCtrls() != null);
  const isShowFullWidth = createMemo(() => getFullWidthCompDetails() != null);
  const showCellsJsx = () => createComponent(For, {
    get each() {
      return getCellCtrls().list;
    },
    children: (cellCtrl) => createComponent(cellComp_default, {
      cellCtrl,
      get editingRow() {
        return rowCtrl.isEditing();
      },
      get printLayout() {
        return rowCtrl.isPrintLayout();
      }
    })
  });
  const showFullWidthJsx = () => createComponent(userComp_default, {
    get compDetails() {
      return getFullWidthCompDetails();
    },
    ref: setFullWidthRef
  });
  return (() => {
    var _el$ = _tmpl$11();
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    insert(_el$, (() => {
      var _c$ = memo(() => !!isShowFullWidth());
      return () => _c$() && showFullWidthJsx();
    })(), null);
    insert(_el$, (() => {
      var _c$2 = memo(() => !!isShowCells());
      return () => _c$2() && showCellsJsx();
    })(), null);
    effect((_p$) => {
      var _v$ = getRowStyles(), _v$2 = getRowIndex(), _v$3 = getRowId(), _v$4 = getRowBusinessKey(), _v$5 = getTabIndex();
      _p$.e = style(_el$, _v$, _p$.e);
      _v$2 !== _p$.t && setAttribute(_el$, "row-index", _p$.t = _v$2);
      _v$3 !== _p$.a && setAttribute(_el$, "row-id", _p$.a = _v$3);
      _v$4 !== _p$.o && setAttribute(_el$, "row-business-key", _p$.o = _v$4);
      _v$5 !== _p$.i && setAttribute(_el$, "tabindex", _p$.i = _v$5);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    });
    return _el$;
  })();
};
var rowComp_default = RowComp;

// src/grid/rows/rowContainerComp.tsx
var _tmpl$12 = /* @__PURE__ */ template(`<div role=rowgroup>`);
var _tmpl$24 = /* @__PURE__ */ template(`<div role=presentation>`);
var RowContainerComp = (props) => {
  const {
    context
  } = useContext(BeansContext);
  const [viewportHeight, setViewportHeight] = createSignal("");
  const [rowCtrlsOrdered, setRowCtrlsOrdered] = createSignal([]);
  const [rowCtrls, setRowCtrls] = createSignal([]);
  const [domOrder, setDomOrder] = createSignal(false);
  const {
    name
  } = props;
  const containerType = createMemo(() => getRowContainerTypeForName(name));
  let eViewport;
  let eContainer;
  const cssClasses = createMemo(() => RowContainerCtrl.getRowContainerCssClasses(name));
  const viewportClasses = createMemo(() => classesList(cssClasses().viewport));
  const containerClasses = createMemo(() => classesList(cssClasses().container));
  const centerTemplate = name === RowContainerName.CENTER || name === RowContainerName.TOP_CENTER || name === RowContainerName.BOTTOM_CENTER || name === RowContainerName.STICKY_TOP_CENTER;
  let rowCtrlsOrderedCopy = [];
  createEffect(() => {
    if (domOrder()) {
      setRowCtrlsOrdered(rowCtrls());
      return;
    }
    const prev = rowCtrlsOrderedCopy;
    const oldRows = prev.filter((r) => rowCtrls().indexOf(r) >= 0);
    const newRows = rowCtrls().filter((r) => oldRows.indexOf(r) < 0);
    const next = [...oldRows, ...newRows];
    setRowCtrlsOrdered(next);
    rowCtrlsOrderedCopy = next;
  });
  onMount(() => {
    const compProxy = {
      setViewportHeight,
      setRowCtrls: ({
        rowCtrls: rowCtrls2
      }) => setRowCtrls(rowCtrls2),
      setDomOrder: (domOrder2) => setDomOrder(domOrder2),
      setContainerWidth: (width) => {
        if (eContainer) {
          eContainer.style.width = width;
        }
      }
    };
    const ctrl = context.createBean(new RowContainerCtrl(name));
    onCleanup(() => context.destroyBean(ctrl));
    ctrl.setComp(compProxy, eContainer, eViewport);
  });
  const viewportStyle = createMemo(() => ({
    height: viewportHeight()
  }));
  const buildContainer = () => (() => {
    var _el$ = _tmpl$12();
    var _ref$ = eContainer;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eContainer = _el$;
    insert(_el$, createComponent(For, {
      get each() {
        return rowCtrlsOrdered();
      },
      children: (rowCtrl, i) => createComponent(rowComp_default, {
        rowCtrl,
        get containerType() {
          return containerType();
        }
      })
    }));
    effect(() => className(_el$, containerClasses()));
    return _el$;
  })();
  return memo(() => centerTemplate ? (() => {
    var _el$2 = _tmpl$24();
    var _ref$2 = eViewport;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eViewport = _el$2;
    insert(_el$2, buildContainer);
    effect((_p$) => {
      var _v$ = viewportClasses(), _v$2 = viewportStyle();
      _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
      _p$.t = style(_el$2, _v$2, _p$.t);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$2;
  })() : buildContainer());
};
var rowContainerComp_default = RowContainerComp;

// src/grid/gridBodyComp.tsx
var _tmpl$13 = /* @__PURE__ */ template(`<div role=treegrid><div role=presentation></div><div role=presentation><div role=presentation></div></div><div role=presentation></div><div role=presentation>`);
var GridBodyComp = () => {
  const {
    context,
    agStackComponentsRegistry,
    resizeObserverService
  } = useContext(BeansContext);
  const [getRowAnimationClass, setRowAnimationClass] = createSignal("");
  const [getAriaColCount, setAriaColCount] = createSignal(0);
  const [getAriaRowCount, setAriaRowCount] = createSignal(0);
  const [getTopHeight, setTopHeight] = createSignal(0);
  const [getBottomHeight, setBottomHeight] = createSignal(0);
  const [getStickyTopHeight, setStickyTopHeight] = createSignal("0px");
  const [getStickyTopTop, setStickyTopTop] = createSignal("0px");
  const [getStickyTopWidth, setStickyTopWidth] = createSignal("100%");
  const [getTopDisplay, setTopDisplay] = createSignal("");
  const [getBottomDisplay, setBottomDisplay] = createSignal("");
  const [getBodyViewportWidth, setBodyViewportWidth] = createSignal("");
  const [getMovingCss, setMovingCss] = createSignal(null);
  const [getForceVerticalScrollClass, setForceVerticalScrollClass] = createSignal(null);
  const [getTopAndBottomOverflowY, setTopAndBottomOverflowY] = createSignal(null);
  const [getCellSelectableCss, setCellSelectableCss] = createSignal(null);
  const [getLayoutClass, setLayoutClass] = createSignal("ag-layout-normal");
  let eRoot;
  let eTop;
  let eStickyTop;
  let eBody;
  let eBodyViewport;
  let eBottom;
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount(() => {
    if (!context) {
      return;
    }
    const newComp = (tag) => {
      const CompClass = agStackComponentsRegistry.getComponentClass(tag);
      const comp = context.createBean(new CompClass());
      onCleanup(() => context.destroyBean(comp));
      return comp;
    };
    eRoot.appendChild(newComp("AG-FAKE-HORIZONTAL-SCROLL").getGui());
    eRoot.appendChild(newComp("AG-OVERLAY-WRAPPER").getGui());
    eBody.appendChild(newComp("AG-FAKE-VERTICAL-SCROLL").getGui());
    const compProxy = {
      setRowAnimationCssOnBodyViewport: setRowAnimationClass,
      setColumnCount: setAriaColCount,
      setRowCount: setAriaRowCount,
      setTopHeight,
      setBottomHeight,
      setStickyTopHeight,
      setStickyTopTop,
      setStickyTopWidth,
      setTopDisplay,
      setBottomDisplay,
      setColumnMovingCss: setMovingCss,
      updateLayoutClasses: setLayoutClass,
      setAlwaysVerticalScrollClass: setForceVerticalScrollClass,
      setPinnedTopBottomOverflowY: setTopAndBottomOverflowY,
      setCellSelectableCss: (cssClass, flag) => setCellSelectableCss(flag ? cssClass : null),
      setBodyViewportWidth,
      registerBodyViewportResizeListener: (listener) => {
        const unsubscribeFromResize = resizeObserverService.observeResize(eBodyViewport, listener);
        destroyFuncs.push(() => unsubscribeFromResize());
      }
    };
    const ctrl = context.createBean(new GridBodyCtrl());
    onCleanup(() => context.destroyBean(ctrl));
    setTimeout(() => ctrl.setComp(compProxy, eRoot, eBodyViewport, eTop, eBottom, eStickyTop), 0);
  });
  const getRootClasses = createMemo(() => classesList("ag-root", "ag-unselectable", getMovingCss(), getLayoutClass()));
  const getBodyClasses = createMemo(() => classesList("ag-body", getLayoutClass()));
  const getBodyViewportClasses = createMemo(() => classesList("ag-body-viewport", getRowAnimationClass(), getLayoutClass(), getForceVerticalScrollClass(), getCellSelectableCss()));
  const getTopClasses = createMemo(() => classesList("ag-floating-top", getCellSelectableCss()));
  const getStickyTopClasses = createMemo(() => classesList("ag-sticky-top", getCellSelectableCss()));
  const getBottomClasses = createMemo(() => classesList("ag-floating-bottom", getCellSelectableCss()));
  const getTopStyle = createMemo(() => ({
    height: `${getTopHeight()}px`,
    "min-height": `${getTopHeight()}px`,
    display: getTopDisplay(),
    "overflow-y": getTopAndBottomOverflowY()
  }));
  const getStickyTopStyle = createMemo(() => ({
    height: getStickyTopHeight(),
    top: getStickyTopTop(),
    width: getStickyTopWidth()
  }));
  const getBottomStyle = createMemo(() => ({
    height: `${getBottomHeight()}px`,
    "min-height": `${getBottomHeight()}px`,
    display: getBottomDisplay(),
    "overflow-y": getTopAndBottomOverflowY()
  }));
  const getBodyViewportStyle = createMemo(() => ({
    width: getBodyViewportWidth()
  }));
  return (() => {
    var _el$ = _tmpl$13(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$5 = _el$3.nextSibling, _el$6 = _el$5.nextSibling;
    var _ref$ = eRoot;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eRoot = _el$;
    insert(_el$, createComponent(gridHeaderComp_default, {}), _el$2);
    var _ref$2 = eTop;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eTop = _el$2;
    insert(_el$2, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.TOP_LEFT;
      }
    }), null);
    insert(_el$2, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.TOP_CENTER;
      }
    }), null);
    insert(_el$2, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.TOP_RIGHT;
      }
    }), null);
    insert(_el$2, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.TOP_FULL_WIDTH;
      }
    }), null);
    var _ref$3 = eBody;
    typeof _ref$3 === "function" ? use(_ref$3, _el$3) : eBody = _el$3;
    var _ref$4 = eBodyViewport;
    typeof _ref$4 === "function" ? use(_ref$4, _el$4) : eBodyViewport = _el$4;
    insert(_el$4, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.LEFT;
      }
    }), null);
    insert(_el$4, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.CENTER;
      }
    }), null);
    insert(_el$4, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.RIGHT;
      }
    }), null);
    insert(_el$4, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.FULL_WIDTH;
      }
    }), null);
    var _ref$5 = eStickyTop;
    typeof _ref$5 === "function" ? use(_ref$5, _el$5) : eStickyTop = _el$5;
    insert(_el$5, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.STICKY_TOP_LEFT;
      }
    }), null);
    insert(_el$5, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.STICKY_TOP_CENTER;
      }
    }), null);
    insert(_el$5, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.STICKY_TOP_RIGHT;
      }
    }), null);
    insert(_el$5, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.STICKY_TOP_FULL_WIDTH;
      }
    }), null);
    var _ref$6 = eBottom;
    typeof _ref$6 === "function" ? use(_ref$6, _el$6) : eBottom = _el$6;
    insert(_el$6, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.BOTTOM_LEFT;
      }
    }), null);
    insert(_el$6, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.BOTTOM_CENTER;
      }
    }), null);
    insert(_el$6, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.BOTTOM_RIGHT;
      }
    }), null);
    insert(_el$6, createComponent(rowContainerComp_default, {
      get name() {
        return RowContainerName.BOTTOM_FULL_WIDTH;
      }
    }), null);
    effect((_p$) => {
      var _v$ = getRootClasses(), _v$2 = getAriaColCount(), _v$3 = getAriaRowCount(), _v$4 = getTopClasses(), _v$5 = getTopStyle(), _v$6 = getBodyClasses(), _v$7 = getBodyViewportClasses(), _v$8 = getBodyViewportStyle(), _v$9 = getStickyTopClasses(), _v$10 = getStickyTopStyle(), _v$11 = getBottomClasses(), _v$12 = getBottomStyle();
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && setAttribute(_el$, "aria-colcount", _p$.t = _v$2);
      _v$3 !== _p$.a && setAttribute(_el$, "aria-rowcount", _p$.a = _v$3);
      _v$4 !== _p$.o && className(_el$2, _p$.o = _v$4);
      _p$.i = style(_el$2, _v$5, _p$.i);
      _v$6 !== _p$.n && className(_el$3, _p$.n = _v$6);
      _v$7 !== _p$.s && className(_el$4, _p$.s = _v$7);
      _p$.h = style(_el$4, _v$8, _p$.h);
      _v$9 !== _p$.r && className(_el$5, _p$.r = _v$9);
      _p$.d = style(_el$5, _v$10, _p$.d);
      _v$11 !== _p$.l && className(_el$6, _p$.l = _v$11);
      _p$.u = style(_el$6, _v$12, _p$.u);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0,
      n: void 0,
      s: void 0,
      h: void 0,
      r: void 0,
      d: void 0,
      l: void 0,
      u: void 0
    });
    return _el$;
  })();
};
var gridBodyComp_default = GridBodyComp;
var _tmpl$14 = /* @__PURE__ */ template(`<div role=presentation>`);
var TabGuardComp = (props) => {
  const {
    children,
    eFocusableElement,
    onTabKeyDown,
    gridCtrl,
    forceFocusOutWhenTabGuardsAreEmpty
  } = props;
  const [tabIndex, setTabIndex] = createSignal();
  let eTopGuard;
  let eBottomGuard;
  let ctrl;
  const {
    context
  } = useContext(BeansContext);
  onMount(() => {
    const compProxy = {
      setTabIndex: (value) => value == null ? setTabIndex(void 0) : setTabIndex(parseInt(value, 10))
    };
    ctrl = context.createBean(new TabGuardCtrl({
      comp: compProxy,
      eTopGuard,
      eBottomGuard,
      eFocusableElement,
      onTabKeyDown,
      forceFocusOutWhenTabGuardsAreEmpty,
      focusInnerElement: (fromBottom) => gridCtrl.focusInnerElement(fromBottom)
    }));
    props.ref({
      forceFocusOutOfContainer(up) {
        ctrl.forceFocusOutOfContainer(up);
      }
    });
  });
  onCleanup(() => context.destroyBean(ctrl));
  return [(() => {
    var _el$ = _tmpl$14();
    var _ref$ = eTopGuard;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eTopGuard = _el$;
    effect((_p$) => {
      var _v$ = `${TabGuardClassNames.TAB_GUARD} ${TabGuardClassNames.TAB_GUARD_TOP}`, _v$2 = tabIndex();
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && setAttribute(_el$, "tabindex", _p$.t = _v$2);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })(), children, (() => {
    var _el$2 = _tmpl$14();
    var _ref$2 = eBottomGuard;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eBottomGuard = _el$2;
    effect((_p$) => {
      var _v$3 = `${TabGuardClassNames.TAB_GUARD} ${TabGuardClassNames.TAB_GUARD_BOTTOM}`, _v$4 = tabIndex();
      _v$3 !== _p$.e && className(_el$2, _p$.e = _v$3);
      _v$4 !== _p$.t && setAttribute(_el$2, "tabindex", _p$.t = _v$4);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$2;
  })()];
};
var tabGuardComp_default = TabGuardComp;

// src/grid/gridComp.tsx
var _tmpl$15 = /* @__PURE__ */ template(`<div><div>`);
var GridComp = (props) => {
  const [rtlClass, setRtlClass] = createSignal("");
  const [keyboardFocusClass, setKeyboardFocusClass] = createSignal("");
  const [layoutClass, setLayoutClass] = createSignal("");
  const [cursor, setCursor] = createSignal(null);
  const [userSelect, setUserSelect] = createSignal(null);
  const [initialised, setInitialised] = createSignal(false);
  const {
    context
  } = props;
  const beans = context.getBean("beans");
  let tabGuardRef;
  const setTabGuardRef = (newRef) => {
    tabGuardRef = newRef;
    tabGuardRef && tabGuardReady();
  };
  let eGui;
  let eBody;
  let gridCtrl;
  const onTabKeyDown = () => void 0;
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  const tabGuardReady = () => {
    const beansToDestroy = [];
    const {
      agStackComponentsRegistry
    } = beans;
    const HeaderDropZonesClass = agStackComponentsRegistry.getComponentClass("AG-GRID-HEADER-DROP-ZONES");
    const SideBarClass = agStackComponentsRegistry.getComponentClass("AG-SIDE-BAR");
    const StatusBarClass = agStackComponentsRegistry.getComponentClass("AG-STATUS-BAR");
    const WatermarkClass = agStackComponentsRegistry.getComponentClass("AG-WATERMARK");
    const PaginationClass = agStackComponentsRegistry.getComponentClass("AG-PAGINATION");
    const additionalEls = [];
    if (gridCtrl.showDropZones() && HeaderDropZonesClass) {
      const headerDropZonesComp = context.createBean(new HeaderDropZonesClass());
      const el = headerDropZonesComp.getGui();
      eGui.insertAdjacentElement("afterbegin", el);
      additionalEls.push(el);
      beansToDestroy.push(headerDropZonesComp);
    }
    if (gridCtrl.showSideBar() && SideBarClass) {
      const sideBarComp = context.createBean(new SideBarClass());
      const el = sideBarComp.getGui();
      const bottomTabGuard = eBody.querySelector(".ag-tab-guard-bottom");
      if (bottomTabGuard) {
        bottomTabGuard.insertAdjacentElement("beforebegin", el);
        additionalEls.push(el);
      }
      beansToDestroy.push(sideBarComp);
    }
    if (gridCtrl.showStatusBar() && StatusBarClass) {
      const statusBarComp = context.createBean(new StatusBarClass());
      const el = statusBarComp.getGui();
      eGui.insertAdjacentElement("beforeend", el);
      additionalEls.push(el);
      beansToDestroy.push(statusBarComp);
    }
    if (PaginationClass) {
      const paginationComp = context.createBean(new PaginationClass());
      const el = paginationComp.getGui();
      eGui.insertAdjacentElement("beforeend", el);
      additionalEls.push(el);
      beansToDestroy.push(paginationComp);
    }
    if (gridCtrl.showWatermark() && WatermarkClass) {
      const watermarkComp = context.createBean(new WatermarkClass());
      const el = watermarkComp.getGui();
      eGui.insertAdjacentElement("beforeend", el);
      additionalEls.push(el);
      beansToDestroy.push(watermarkComp);
    }
    destroyFuncs.push(() => {
      context.destroyBeans(beansToDestroy);
      additionalEls.forEach((el) => {
        if (el.parentElement) {
          el.parentElement.removeChild(el);
        }
      });
    });
  };
  onMount(() => {
    gridCtrl = context.createBean(new GridCtrl());
    destroyFuncs.push(() => context.destroyBean(gridCtrl));
    const compProxy = {
      destroyGridUi: () => {
      },
      // do nothing, as framework users destroy grid by removing the comp
      setRtlClass,
      forceFocusOutOfContainer: (up) => {
        tabGuardRef && tabGuardRef.forceFocusOutOfContainer(up);
      },
      updateLayoutClasses: setLayoutClass,
      getFocusableContainers: () => {
        const els = [];
        const gridBodyCompEl = eGui.querySelector(".ag-root");
        const sideBarEl = eGui.querySelector(".ag-side-bar:not(.ag-hidden)");
        if (gridBodyCompEl) {
          els.push(gridBodyCompEl);
        }
        if (sideBarEl) {
          els.push(sideBarEl);
        }
        return els;
      },
      setCursor,
      setUserSelect
    };
    gridCtrl.setComp(compProxy, eGui, eGui);
    setInitialised(true);
  });
  const cssClasses = createMemo(() => classesList("ag-root-wrapper", rtlClass(), keyboardFocusClass(), layoutClass(), props.class));
  const bodyCssClasses = createMemo(() => classesList("ag-root-wrapper-body", "ag-focus-managed", layoutClass()));
  const topStyle = createMemo(() => ({
    userSelect: userSelect != null ? userSelect() : "",
    WebkitUserSelect: userSelect != null ? userSelect() : "",
    cursor: cursor != null ? cursor() : ""
  }));
  return (() => {
    var _el$ = _tmpl$15(), _el$2 = _el$.firstChild;
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    var _ref$2 = eBody;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : eBody = _el$2;
    insert(_el$2, (() => {
      var _c$ = memo(() => !!initialised());
      return () => _c$() && // we wait for initialised before rending the children, so GridComp has created and registered with it's
      // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
      // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
      // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
      // hangs the UI)
      createComponent(BeansContext.Provider, {
        value: beans,
        get children() {
          return createComponent(tabGuardComp_default, {
            ref: setTabGuardRef,
            eFocusableElement: eGui,
            onTabKeyDown,
            gridCtrl,
            forceFocusOutWhenTabGuardsAreEmpty: true,
            get children() {
              return createComponent(gridBodyComp_default, {});
            }
          });
        }
      });
    })());
    effect((_p$) => {
      var _v$ = cssClasses(), _v$2 = topStyle(), _v$3 = bodyCssClasses();
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _p$.t = style(_el$, _v$2, _p$.t);
      _v$3 !== _p$.a && className(_el$2, _p$.a = _v$3);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$;
  })();
};
var gridComp_default = GridComp;

// src/grid/agGridSolid.tsx
var _tmpl$16 = /* @__PURE__ */ template(`<div>`);
var AgGridSolid = function(props) {
  let eGui;
  let api;
  const [context, setContext] = createSignal();
  const [getPortals, setPortals] = createSignal([]);
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  const propsCopy = {};
  Object.keys(props).forEach((key) => propsCopy[key] = props[key]);
  createEffect(() => {
    const keys = Object.keys(props);
    const changes = {};
    let changesExist = false;
    keys.forEach((key) => {
      const currentValue = props[key];
      const previousValue = propsCopy[key];
      if (previousValue !== currentValue) {
        changes[key] = currentValue;
        propsCopy[key] = currentValue;
        changesExist = true;
      }
    });
    if (changesExist) {
      ComponentUtil.processOnChange(changes, api);
    }
  });
  onMount(() => {
    const modules = props.modules || [];
    const portalManager = {
      addPortal: (info) => {
        setPortals([...getPortals(), info]);
      },
      removePortal: (info) => {
        setPortals(getPortals().filter((item) => item != info));
      }
    };
    const gridParams = {
      providedBeanInstances: {
        frameworkComponentWrapper: new SolidCompWrapperFactory(portalManager)
      },
      modules,
      frameworkOverrides: new SolidFrameworkOverrides()
    };
    const gridOptions = ComponentUtil.combineAttributesAndGridOptions(props.gridOptions, props);
    const createUiCallback = (context2) => {
      setContext(context2);
      const ctrlsService = context2.getBean(CtrlsService.NAME);
      ctrlsService.whenReady(() => {
        const refCallback = props.ref && props.ref;
        if (refCallback) {
          const gridRef = {
            api,
            columnApi: new ColumnApi(api)
          };
          refCallback(gridRef);
        }
        destroyFuncs.push(() => api.destroy());
      });
    };
    const acceptChangesCallback = () => {
    };
    const gridCoreCreator = new GridCoreCreator();
    api = gridCoreCreator.create(
      // @ts-ignore
      eGui,
      gridOptions,
      createUiCallback,
      acceptChangesCallback,
      gridParams
    );
  });
  return (() => {
    var _el$ = _tmpl$16();
    var _ref$ = eGui;
    typeof _ref$ === "function" ? use(_ref$, _el$) : eGui = _el$;
    _el$.style.setProperty("height", "100%");
    insert(_el$, (() => {
      var _c$ = memo(() => !!context());
      return () => _c$() && createComponent(gridComp_default, {
        get ["class"]() {
          return props.class;
        },
        get context() {
          return context();
        }
      });
    })(), null);
    insert(_el$, createComponent(For, {
      get each() {
        return getPortals();
      },
      children: (info, i) => createComponent(Portal, {
        get mount() {
          return info.mount;
        },
        get children() {
          return createComponent(info.SolidClass, mergeProps(() => info.props, {
            ref(r$) {
              var _ref$2 = info.ref;
              typeof _ref$2 === "function" ? _ref$2(r$) : info.ref = r$;
            }
          }));
        }
      })
    }), null);
    return _el$;
  })();
};
var agGridSolid_default = AgGridSolid;

// src/index.tsx
var src_default = agGridSolid_default;

export { src_default as default };
