import { ssr, escape, createComponent, Portal, mergeProps, ssrAttribute, ssrStyle, ssrElement } from 'solid-js/web';
import { ComponentUtil, GridCoreCreator, BaseComponentWrapper, VanillaFrameworkOverrides, CtrlsService, ColumnApi, GridCtrl, GroupCellRendererCtrl, _, GridBodyCtrl, RowContainerName, TabGuardCtrl, TabGuardClassNames, GridHeaderCtrl, getRowContainerTypeForName, RowContainerCtrl, HeaderRowContainerCtrl, CssClassManager, HeaderRowType, AgPromise, PopupEditorWrapper } from 'ag-grid-community';
import { createContext, createSignal, onCleanup, createEffect, onMount, For, createMemo, useContext } from 'solid-js';

// src/grid/agGridSolid.tsx

// src/grid/core/solidCompWrapper.tsx
var SolidCompWrapper = class {
  constructor(SolidCompClass, portalManager) {
    this.SolidCompClass = SolidCompClass;
    this.portalManager = portalManager;
  }
  init(props) {
    this.eGui = document.createElement("div");
    this.eGui.className = "ag-solid-container";
    this.portalInfo = {
      mount: this.eGui,
      SolidClass: this.SolidCompClass,
      props,
      ref: (instance) => {
        this.instance = instance;
      }
    };
    this.portalManager.addPortal(this.portalInfo);
  }
  destroy() {
    this.portalInfo && this.portalManager.removePortal(this.portalInfo);
  }
  getGui() {
    return this.eGui;
  }
  hasMethod(name) {
    return this.instance[name] != null;
  }
  getFrameworkComponentInstance() {
    return this.instance;
  }
  callMethod(name, args) {
    return this.instance[name].apply(this.instance, args);
  }
  addMethod(name, callback) {
    this[name] = callback;
  }
};

// src/grid/core/solidCompWrapperFactory.tsx
var SolidCompWrapperFactory = class extends BaseComponentWrapper {
  constructor(portalManager) {
    super();
    this.portalManager = portalManager;
  }
  createWrapper(SolidComponentClass) {
    return new SolidCompWrapper(SolidComponentClass, this.portalManager);
  }
};
var BeansContext = createContext({});

// src/grid/core/utils.tsx
var classesList = (...list) => {
  const filtered = list.filter((s) => s != null && s !== "");
  return filtered.join(" ");
};
var CssClasses = class _CssClasses {
  classesMap = {};
  constructor(...initialClasses) {
    initialClasses.forEach((className) => {
      this.classesMap[className] = true;
    });
  }
  setClass(className, on) {
    const nothingHasChanged = !!this.classesMap[className] == on;
    if (nothingHasChanged) {
      return this;
    }
    const res = new _CssClasses();
    res.classesMap = {
      ...this.classesMap
    };
    res.classesMap[className] = on;
    return res;
  }
  toString() {
    const res = Object.keys(this.classesMap).filter((key) => this.classesMap[key]).join(" ");
    return res;
  }
};

// src/grid/cellRenderer/detailCellRenderer.tsx
var _tmpl$ = ["<div", ">", "</div>"];
var DetailCellRenderer = (props) => {
  const {
    ctrlsFactory,
    context,
    gridOptionsService,
    resizeObserverService,
    clientSideRowModel,
    serverSideRowModel
  } = useContext(BeansContext);
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getGridCssClasses, setGridCssClasses] = createSignal(new CssClasses());
  const [getDetailGridOptions, setDetailGridOptions] = createSignal();
  const [getDetailRowData, setDetailRowData] = createSignal();
  let ctrl;
  let eGuiRef;
  const getCssClassesStr = createMemo(() => getCssClasses().toString() + " ag-details-row");
  const getGridCssClassesStr = createMemo(() => getGridCssClasses().toString() + " ag-details-grid");
  props.ref(() => ({
    // force new instance when grid tries to refresh
    refresh() {
      return ctrl.refresh();
    }
  }));
  onMount(() => {
    if (props.template && typeof props.template === "string") ;
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      addOrRemoveDetailGridCssClass: (name, on) => setGridCssClasses(getGridCssClasses().setClass(name, on)),
      setDetailGrid: (gridOptions) => setDetailGridOptions(gridOptions),
      setRowData: (rowData) => setDetailRowData(rowData),
      getGui: () => eGuiRef
    };
    ctrl = ctrlsFactory.getInstance("detailCellRenderer");
    if (!ctrl) {
      return;
    }
    context.createBean(ctrl);
    ctrl.init(compProxy, props);
    let resizeObserverDestroyFunc;
    if (gridOptionsService.get("detailRowAutoHeight")) {
      const checkRowSizeFunc = () => {
        {
          return;
        }
      };
      resizeObserverDestroyFunc = resizeObserverService.observeResize(eGuiRef, checkRowSizeFunc);
    }
    return () => {
      context.destroyBean(ctrl);
      if (resizeObserverDestroyFunc) {
        resizeObserverDestroyFunc();
      }
    };
  });
  return ssr(_tmpl$, ssrAttribute("class", escape(getCssClassesStr(), true), false), getDetailGridOptions() && escape(createComponent(agGridSolid_default, mergeProps({
    get ["class"]() {
      return getGridCssClassesStr();
    }
  }, getDetailGridOptions, {
    get rowData() {
      return getDetailRowData();
    }
  }))));
};
var detailCellRenderer_default = DetailCellRenderer;
var JsUserComp = (p) => {
  const {
    context
  } = useContext(BeansContext);
  const promise = p.compDetails.newAgStackInstance();
  if (!promise) {
    return [];
  }
  const comp = promise.resolveNow(null, (x) => x);
  if (!comp) {
    return [];
  }
  p.ref && p.ref(comp);
  const gui = comp.getGui();
  onCleanup(() => {
    comp && context.destroyBean(comp);
    p.ref && p.ref(void 0);
  });
  return gui;
};
var jsUserComp_default = JsUserComp;
var SolidUserComp = (props) => {
  const SolidClass = props.compDetails.componentClass;
  onCleanup(() => {
  });
  return createComponent(SolidClass, mergeProps(() => props.compDetails.params));
};
var solidUserComp_default = SolidUserComp;

// src/grid/userComps/userComp.tsx
var UserComp = (p) => {
  const showSolidComp = createMemo(() => {
    const details = p.compDetails;
    if (!details) {
      return false;
    }
    return details.componentFromFramework;
  });
  const showJsComp = createMemo(() => {
    const details = p.compDetails;
    if (!details) {
      return false;
    }
    return !details.componentFromFramework;
  });
  return [showSolidComp() && createComponent(solidUserComp_default, {
    get compDetails() {
      return p.compDetails;
    }
  }), showJsComp() && createComponent(jsUserComp_default, {
    get compDetails() {
      return p.compDetails;
    }
  })];
};
var userComp_default = UserComp;

// src/grid/cellRenderer/groupCellRenderer.tsx
var _tmpl$2 = ["<span", "></span>"];
var _tmpl$22 = ['<span class="ag-group-value">', "", "</span>"];
var _tmpl$3 = ['<span class="ag-group-child-count">', "</span>"];
var GroupCellRenderer = (props) => {
  const context = useContext(BeansContext).context;
  let eGui;
  let eCheckboxRef;
  let eExpandedRef;
  let eContractedRef;
  let role = "gridcell";
  const [getInnerCompDetails, setInnerCompDetails] = createSignal();
  const [getChildCount, setChildCount] = createSignal();
  const [getValue, setValue] = createSignal();
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getExpandedCssClasses, setExpandedCssClasses] = createSignal(new CssClasses("ag-hidden"));
  const [getContractedCssClasses, setContractedCssClasses] = createSignal(new CssClasses("ag-hidden"));
  const [getCheckboxCssClasses, setCheckboxCssClasses] = createSignal(new CssClasses("ag-invisible"));
  props.ref(() => ({
    // force new instance when grid tries to refresh
    refresh() {
      return false;
    }
  }));
  onMount(() => {
    const compProxy = {
      setInnerRenderer: (details, valueToDisplay) => {
        setInnerCompDetails(details);
        const escapedValue = _.escapeString(valueToDisplay, true);
        setValue(escapedValue);
      },
      setChildCount: (count) => setChildCount(count),
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setContractedDisplayed: (displayed) => setContractedCssClasses(getContractedCssClasses().setClass("ag-hidden", !displayed)),
      setExpandedDisplayed: (displayed) => setExpandedCssClasses(getExpandedCssClasses().setClass("ag-hidden", !displayed)),
      setCheckboxVisible: (visible) => setCheckboxCssClasses(getCheckboxCssClasses().setClass("ag-invisible", !visible))
    };
    const ctrl = context.createBean(new GroupCellRendererCtrl());
    ctrl.init(compProxy, eGui, eCheckboxRef, eExpandedRef, eContractedRef, GroupCellRenderer, props);
    eGui.setAttribute("role", ctrl.getCellAriaRole());
    role = ctrl.getCellAriaRole();
    return () => {
      context.destroyBean(ctrl);
    };
  });
  const getClassName = createMemo(() => `ag-cell-wrapper ${getCssClasses().toString()}`);
  const getExpandedClassName = createMemo(() => `ag-group-expanded ${getExpandedCssClasses().toString()}`);
  const getContractedClassName = createMemo(() => `ag-group-contracted ${getContractedCssClasses().toString()}`);
  const getCheckboxClassName = createMemo(() => `ag-group-checkbox ${getCheckboxCssClasses().toString()}`);
  const isShowUserComp = () => getInnerCompDetails() != null;
  const isShowValue = () => getInnerCompDetails() == null && getValue() != null;
  return ssrElement("span", mergeProps({
    get ["class"]() {
      return getClassName();
    }
  }, () => !props.colDef ? {
    role
  } : {}), [ssr(_tmpl$2, ssrAttribute("class", escape(getExpandedClassName(), true), false)), ssr(_tmpl$2, ssrAttribute("class", escape(getContractedClassName(), true), false)), ssr(_tmpl$2, ssrAttribute("class", escape(getCheckboxClassName(), true), false)), ssr(_tmpl$22, isShowUserComp() && escape(createComponent(userComp_default, {
    get compDetails() {
      return getInnerCompDetails();
    }
  })), isShowValue() && escape(getValue())), ssr(_tmpl$3, escape(getChildCount()))], false);
};
var groupCellRenderer_default = GroupCellRenderer;

// src/grid/core/solidFrameworkOverrides.tsx
var SolidFrameworkOverrides = class extends VanillaFrameworkOverrides {
  constructor() {
    super("solid");
  }
  frameworkComponents = {
    agGroupCellRenderer: groupCellRenderer_default,
    agGroupRowRenderer: groupCellRenderer_default,
    agDetailCellRenderer: detailCellRenderer_default
  };
  frameworkComponent(name) {
    return this.frameworkComponents[name];
  }
  isFrameworkComponent(comp) {
    if (!comp) {
      return false;
    }
    const prototype = comp.prototype;
    const isJsComp = prototype && "getGui" in prototype;
    return !isJsComp;
  }
};
var _tmpl$4 = ['<div class="ag-header-cell" style="', '"', ' role="columnheader"><div class="ag-header-cell-resize" role="presentation"></div><div class="ag-header-cell-comp-wrapper" role="presentation">', "</div></div>"];
var HeaderCellComp = (props) => {
  const {
    ctrl
  } = props;
  const [getWidth, setWidth] = createSignal();
  const [getColId, setColId] = createSignal(ctrl.getColId());
  const [getAriaSort, setAriaSort] = createSignal();
  const [getUserCompDetails, setUserCompDetails] = createSignal();
  let eGui;
  let eResize;
  let eHeaderCompWrapper;
  let userComp;
  const cssClassManager = new CssClassManager(() => eGui);
  onMount(() => {
    const compProxy = {
      setWidth: (width) => setWidth(width),
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setAriaSort: (sort) => setAriaSort(sort),
      setUserCompDetails: (compDetails) => setUserCompDetails(compDetails),
      getUserCompInstance: () => userComp
    };
    ctrl.setComp(compProxy, eGui, eResize, eHeaderCompWrapper);
    const selectAllGui = ctrl.getSelectAllGui();
    eResize.insertAdjacentElement("afterend", selectAllGui);
    ctrl.setDragSource(eGui);
  });
  const style = createMemo(() => ({
    width: getWidth()
  }));
  return ssr(_tmpl$4, ssrStyle(style()), ssrAttribute("col-id", escape(getColId(), true), false) + ssrAttribute("aria-sort", escape(getAriaSort(), true), false), getUserCompDetails() && escape(createComponent(userComp_default, {
    get compDetails() {
      return getUserCompDetails();
    }
  })));
};
var headerCellComp_default = HeaderCellComp;
var _tmpl$5 = ["<div", ' style="', '" role="gridcell"><div', ' role="presentation">', "</div><div", ' role="presentation"><button type="button" class="ag-button ag-floating-filter-button-button"', "></button></div></div>"];
var HeaderFilterCellComp = (props) => {
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getCssBodyClasses, setBodyCssClasses] = createSignal(new CssClasses());
  const [getCssButtonWrapperClasses, setButtonWrapperCssClasses] = createSignal(new CssClasses());
  const [getButtonWrapperAriaHidden, setButtonWrapperAriaHidden] = createSignal("false");
  const [getWidth, setWidth] = createSignal();
  const [getUserCompDetails, setUserCompDetails] = createSignal();
  let eGui;
  let eFloatingFilterBody;
  let eButtonShowMainFilter;
  let userCompPromise;
  onMount(() => {
    userCompPromise = new AgPromise((resolve) => {
    });
  });
  const {
    ctrl
  } = props;
  onMount(() => {
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses((prev) => prev.setClass(name, on)),
      addOrRemoveBodyCssClass: (name, on) => setBodyCssClasses((prev) => prev.setClass(name, on)),
      setButtonWrapperDisplayed: (displayed) => {
        setButtonWrapperCssClasses((prev) => prev.setClass("ag-hidden", !displayed));
        setButtonWrapperAriaHidden(!displayed ? "true" : "false");
      },
      setWidth: (width) => setWidth(width),
      setCompDetails: (compDetails) => setUserCompDetails(compDetails),
      getFloatingFilterComp: () => userCompPromise,
      setMenuIcon: (eIcon) => eButtonShowMainFilter.appendChild(eIcon)
    };
    ctrl.setComp(compProxy, eGui, eButtonShowMainFilter, eFloatingFilterBody);
  });
  const getStyle = createMemo(() => ({
    width: getWidth()
  }));
  const getCssClassesString = createMemo(() => "ag-header-cell ag-floating-filter " + getCssClasses().toString());
  const getBodyCssClassesString = createMemo(() => getCssBodyClasses().toString());
  const getButtonWrapperCssClassesString = createMemo(() => "ag-floating-filter-button " + getCssButtonWrapperClasses().toString());
  return ssr(_tmpl$5, ssrAttribute("class", escape(getCssClassesString(), true), false), ssrStyle(getStyle()), ssrAttribute("class", escape(getBodyCssClassesString(), true), false), getUserCompDetails() && escape(createComponent(userComp_default, {
    get compDetails() {
      return getUserCompDetails();
    }
  })), ssrAttribute("aria-hidden", escape(getButtonWrapperAriaHidden(), true), false) + ssrAttribute("class", escape(getButtonWrapperCssClassesString(), true), false), ssrAttribute("tabindex", -1, false));
};
var headerFilterCellComp_default = HeaderFilterCellComp;
var _tmpl$6 = ["<div", ' style="', '"', ' role="columnheader"', ">", "<div", "></div></div>"];
var HeaderGroupCellComp = (props) => {
  const {
    ctrl
  } = props;
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getCssResizableClasses, setResizableCssClasses] = createSignal(new CssClasses());
  const [getResizableAriaHidden, setResizableAriaHidden] = createSignal("false");
  const [getWidth, setWidth] = createSignal();
  const [getColId, setColId] = createSignal(ctrl.getColId());
  const [getAriaExpanded, setAriaExpanded] = createSignal();
  const [getUserCompDetails, setUserCompDetails] = createSignal();
  let eGui;
  let eResize;
  onMount(() => {
    const compProxy = {
      setWidth: (width) => setWidth(width),
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setUserCompDetails: (compDetails) => setUserCompDetails(compDetails),
      setResizableDisplayed: (displayed) => {
        setResizableCssClasses((prev) => prev.setClass("ag-hidden", !displayed));
        setResizableAriaHidden(!displayed ? "true" : "false");
      },
      setAriaExpanded: (expanded) => setAriaExpanded(expanded)
    };
    ctrl.setComp(compProxy, eGui, eResize);
  });
  createEffect(() => {
    const userCompDetails = getUserCompDetails();
    if (userCompDetails == null) {
      return;
    }
    ctrl.setDragSource(eGui);
  });
  const style = createMemo(() => ({
    width: getWidth()
  }));
  const getClassName = createMemo(() => "ag-header-group-cell " + getCssClasses().toString());
  const getResizableClassName = createMemo(() => "ag-header-cell-resize " + getCssResizableClasses().toString());
  return ssr(_tmpl$6, ssrAttribute("class", escape(getClassName(), true), false), ssrStyle(style()), ssrAttribute("col-id", escape(getColId(), true), false), ssrAttribute("aria-expanded", escape(getAriaExpanded(), true), false), getUserCompDetails() && escape(createComponent(userComp_default, {
    get compDetails() {
      return getUserCompDetails();
    }
  })), ssrAttribute("aria-hidden", escape(getResizableAriaHidden(), true), false) + ssrAttribute("class", escape(getResizableClassName(), true), false));
};
var headerGroupCellComp_default = HeaderGroupCellComp;

// src/grid/header/headerRowComp.tsx
var _tmpl$7 = ["<div", ' role="row" style="', '"', ">", "</div>"];
var HeaderRowComp = (props) => {
  const {
    gridOptionsService
  } = useContext(BeansContext);
  const {
    ctrl
  } = props;
  const [getHeight, setHeight] = createSignal();
  const [getTop, setTop] = createSignal();
  const [getWidth, setWidth] = createSignal();
  const [getAriaRowIndex, setAriaRowIndex] = createSignal(ctrl.getAriaRowIndex());
  const [getCellCtrls, setCellCtrls] = createSignal([]);
  const setCellCtrlsMaintainOrder = (next) => {
    const prev = getCellCtrls();
    const isEnsureDomOrder = gridOptionsService.get("ensureDomOrder");
    const isPrintLayout = gridOptionsService.isDomLayout("print");
    if (isEnsureDomOrder || isPrintLayout) {
      return next;
    }
    const prevMap = _.mapById(prev, (c) => c.getInstanceId());
    const nextMap = _.mapById(next, (c) => c.getInstanceId());
    const oldCtrlsWeAreKeeping = prev.filter((c) => nextMap.has(c.getInstanceId()));
    const newCtrls = next.filter((c) => !prevMap.has(c.getInstanceId()));
    const nextOrderMaintained = [...oldCtrlsWeAreKeeping, ...newCtrls];
    setCellCtrls(nextOrderMaintained);
  };
  onMount(() => {
    const compProxy = {
      setHeight: (height) => setHeight(height),
      setTop: (top) => setTop(top),
      setHeaderCtrls: (ctrls) => setCellCtrlsMaintainOrder(ctrls),
      setWidth: (width) => setWidth(width)
    };
    ctrl.setComp(compProxy);
  });
  const style = createMemo(() => ({
    height: getHeight(),
    top: getTop(),
    width: getWidth()
  }));
  const cssClasses = ctrl.getHeaderRowClass();
  const createCellJsx = (cellCtrl) => {
    switch (ctrl.getType()) {
      case HeaderRowType.COLUMN_GROUP:
        return createComponent(headerGroupCellComp_default, {
          ctrl: cellCtrl
        });
      case HeaderRowType.FLOATING_FILTER:
        return createComponent(headerFilterCellComp_default, {
          ctrl: cellCtrl
        });
      default:
        return createComponent(headerCellComp_default, {
          ctrl: cellCtrl
        });
    }
  };
  return ssr(_tmpl$7, ssrAttribute("class", escape(cssClasses, true), false), ssrStyle(style()), ssrAttribute("aria-rowindex", escape(getAriaRowIndex(), true), false), escape(createComponent(For, {
    get each() {
      return getCellCtrls();
    },
    children: (cellCtrl, i) => createCellJsx(cellCtrl)
  })));
};
var headerRowComp_default = HeaderRowComp;

// src/grid/header/headerRowContainerComp.tsx
var _tmpl$8 = ["<div", ' role="rowgroup" style="', '">', "</div>"];
var _tmpl$23 = ["<div", ' role="presentation"><div class="ag-header-container" role="rowgroup" style="', '">', "</div></div>"];
var HeaderRowContainerComp = (props) => {
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getAriaHidden, setAriaHidden] = createSignal(false);
  const [getCenterContainerWidth, setCenterContainerWidth] = createSignal();
  const [getPinnedContainerWidth, setPinnedContainerWidth] = createSignal();
  const [getHeaderRowCtrls, setHeaderRowCtrls] = createSignal([]);
  const {
    context
  } = useContext(BeansContext);
  let eGui;
  const pinnedLeft = props.pinned === "left";
  const pinnedRight = props.pinned === "right";
  const centre = !pinnedLeft && !pinnedRight;
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount(() => {
    const compProxy = {
      setDisplayed: (displayed) => {
        setCssClasses(getCssClasses().setClass("ag-hidden", !displayed));
        setAriaHidden(!displayed);
      },
      setCtrls: (ctrls) => setHeaderRowCtrls(ctrls),
      // centre only
      setCenterWidth: (width) => setCenterContainerWidth(width),
      setViewportScrollLeft: (left) => eGui.scrollLeft = left,
      // pinned only
      setPinnedContainerWidth: (width) => setPinnedContainerWidth(width)
    };
    const ctrl = context.createBean(new HeaderRowContainerCtrl(props.pinned));
    ctrl.setComp(compProxy, eGui);
    destroyFuncs.push(() => context.destroyBean(ctrl));
  });
  const getClassName = createMemo(() => getCssClasses().toString());
  const insertRowsJsx = () => createComponent(For, {
    get each() {
      return getHeaderRowCtrls();
    },
    children: (ctrl) => createComponent(headerRowComp_default, {
      ctrl
    })
  });
  const eCenterContainerStyle = createMemo(() => ({
    width: getCenterContainerWidth()
  }));
  const ePinnedStyle = createMemo(() => ({
    width: getPinnedContainerWidth(),
    "min-width": getPinnedContainerWidth(),
    "max-width": getPinnedContainerWidth()
  }));
  return [pinnedLeft && ssr(_tmpl$8, ssrAttribute("class", "ag-pinned-left-header " + escape(getClassName(), true), false) + ssrAttribute("aria-hidden", escape(getAriaHidden(), true), false), ssrStyle(ePinnedStyle()), escape(insertRowsJsx())), pinnedRight && ssr(_tmpl$8, ssrAttribute("class", "ag-pinned-right-header " + escape(getClassName(), true), false) + ssrAttribute("aria-hidden", escape(getAriaHidden(), true), false), ssrStyle(ePinnedStyle()), escape(insertRowsJsx())), centre && ssr(_tmpl$23, ssrAttribute("class", "ag-header-viewport " + escape(getClassName(), true), false), ssrStyle(eCenterContainerStyle()), escape(insertRowsJsx()))];
};
var headerRowContainerComp_default = HeaderRowContainerComp;

// src/grid/header/gridHeaderComp.tsx
var _tmpl$9 = ["<div", ' style="', '" role="presentation">', "", "", "</div>"];
var GridHeaderComp = () => {
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getHeight, setHeight] = createSignal();
  const {
    context
  } = useContext(BeansContext);
  let eGui;
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount(() => {
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setHeightAndMinHeight: (height) => setHeight(height)
    };
    const ctrl = context.createBean(new GridHeaderCtrl());
    ctrl.setComp(compProxy, eGui, eGui);
    destroyFuncs.push(() => context.destroyBean(ctrl));
  });
  const className = createMemo(() => {
    let res = getCssClasses().toString();
    return "ag-header " + res;
  });
  const style = createMemo(() => ({
    height: getHeight(),
    "min-height": getHeight()
  }));
  return ssr(_tmpl$9, ssrAttribute("class", escape(className(), true), false), ssrStyle(style()), escape(createComponent(headerRowContainerComp_default, {
    pinned: "left"
  })), escape(createComponent(headerRowContainerComp_default, {
    pinned: null
  })), escape(createComponent(headerRowContainerComp_default, {
    pinned: "right"
  })));
};
var gridHeaderComp_default = GridHeaderComp;
var PopupEditorComp = (props) => {
  const {
    context,
    popupService,
    localeService,
    gridOptionsService
  } = useContext(BeansContext);
  const {
    editDetails,
    cellCtrl,
    eParentCell
  } = props;
  const {
    compDetails
  } = editDetails;
  const useModelPopup = gridOptionsService.get("stopEditingWhenCellsLoseFocus");
  const wrapper = context.createBean(new PopupEditorWrapper(compDetails.params));
  const ePopupGui = wrapper.getGui();
  const positionParams = {
    column: cellCtrl.getColumn(),
    rowNode: cellCtrl.getRowNode(),
    type: "popupCellEditor",
    eventSource: eParentCell,
    ePopup: ePopupGui,
    position: editDetails.popupPosition,
    keepWithinBounds: true
  };
  const positionCallback = popupService.positionPopupByComponent.bind(popupService, positionParams);
  const translate = localeService.getLocaleTextFunc();
  const addPopupRes = popupService.addPopup({
    modal: useModelPopup,
    eChild: ePopupGui,
    closeOnEsc: true,
    closedCallback: () => {
      cellCtrl.onPopupEditorClosed();
    },
    anchorToElement: eParentCell,
    positionCallback,
    ariaLabel: translate("ariaLabelCellEditor", "Cell Editor")
  });
  const hideEditorPopup = addPopupRes ? addPopupRes.hideFunc : void 0;
  onCleanup(() => {
    if (hideEditorPopup != null) {
      hideEditorPopup();
    }
    context.destroyBean(wrapper);
  });
  return createComponent(Portal, {
    mount: ePopupGui,
    get children() {
      return props.children;
    }
  });
};
var popupEditorComp_default = PopupEditorComp;

// src/grid/cells/showEditDetails.tsx
var ShowEditDetails = (props) => {
  const getCompDetails = createMemo(() => props.editDetails.compDetails);
  const compDetails = props.editDetails.compDetails;
  if (!compDetails) {
    return [];
  }
  const inPopup = props.editDetails.popup;
  const eGui = props.eGuiFn();
  return [inPopup && createComponent(popupEditorComp_default, {
    get cellCtrl() {
      return props.cellCtrl;
    },
    eParentCell: eGui,
    get editDetails() {
      return props.editDetails;
    },
    get children() {
      return createComponent(userComp_default, {
        get compDetails() {
          return getCompDetails();
        }
      });
    }
  }), !inPopup && createComponent(userComp_default, {
    get compDetails() {
      return getCompDetails();
    }
  })];
};
var showEditDetails_default = ShowEditDetails;
var _tmpl$10 = ['<span role="presentation" id="', '" class="ag-cell-value">', "</span>"];
var ToolsComp = (props) => {
  const {
    context
  } = useContext(BeansContext);
  const CompWrapper = (innerProps) => {
    const comp = innerProps.createFn();
    if (!comp) {
      return [];
    }
    onCleanup(() => context.destroyBean(comp));
    return comp.getGui();
  };
  return [props.includeSelection && createComponent(CompWrapper, {
    createFn: () => {
      const checkboxSelectionComp = props.cellCtrl.createSelectionCheckbox();
      props.setSelectionCheckboxId(checkboxSelectionComp.getCheckboxId());
      return checkboxSelectionComp;
    }
  }), props.includeDndSource && createComponent(CompWrapper, {
    createFn: () => props.cellCtrl.createDndSource()
  }), props.includeRowDrag && createComponent(CompWrapper, {
    createFn: () => props.cellCtrl.createRowDragComp()
  })];
};
var ShowRenderDetails = (props) => {
  const getCompDetails = createMemo(() => props.showDetails.compDetails);
  const isNoCompDetails = createMemo(() => props.showDetails.compDetails == null);
  const valueForNoCellRenderer = () => {
    const value = props.showDetails.value;
    return value && value.toString ? value.toString() : value;
  };
  const bodyJsxFunc = () => [isNoCompDetails() && valueForNoCellRenderer(), getCompDetails() && createComponent(userComp_default, {
    get compDetails() {
      return getCompDetails();
    }
  })];
  return [props.showTools && createComponent(ToolsComp, {
    get includeDndSource() {
      return props.includeDndSource;
    },
    get includeRowDrag() {
      return props.includeRowDrag;
    },
    get includeSelection() {
      return props.includeSelection;
    },
    get setSelectionCheckboxId() {
      return props.setSelectionCheckboxId;
    },
    get cellCtrl() {
      return props.cellCtrl;
    }
  }), props.showCellWrapper ? ssr(_tmpl$10, `cell-${escape(props.cellInstanceId, true)}`, escape(bodyJsxFunc())) : bodyJsxFunc()];
};
var showRenderDetails_default = ShowRenderDetails;

// src/grid/cells/cellComp.tsx
var _tmpl$11 = ['<div style="', '"', "> ", "</div>"];
var _tmpl$24 = ['<div class="ag-cell-wrapper" role="presentation">', "</div>"];
var checkCellEditorDeprecations = (popup, cellEditor, cellCtrl) => {
  const col = cellCtrl.getColumn();
  if (!popup && cellEditor.isPopup && cellEditor.isPopup()) {
    `AG Grid: Found an issue in column ${col.getColId()}. If using SolidJS, specify an editor is a popup using colDef.cellEditorPopup=true. AG Grid SolidJS cannot depend on the editor component specifying if it's in a popup (via the isPopup() method on the editor), as SolidJS needs to know this information BEFORE the component is created.`;
    _.doOnce(() => void 0, "jsEditorComp-isPopup-" + cellCtrl.getColumn().getColId());
  }
  if (popup && cellEditor.getPopupPosition && cellEditor.getPopupPosition() != null) {
    `AG Grid: Found an issue in column ${col.getColId()}. If using SolidJS, specify an editor popup position using colDef.cellEditorPopupPosition=true. AG Grid SolidJS cannot depend on the editor component specifying it's position (via the getPopupPosition() method on the editor), as SolidJS needs to know this information BEFORE the component is created.`;
    _.doOnce(() => void 0, "jsEditorComp-getPopupPosition-" + cellCtrl.getColumn().getColId());
  }
};
var CellComp = (props) => {
  const {
    cellCtrl,
    printLayout,
    editingRow
  } = props;
  const [renderDetails, setRenderDetails] = createSignal();
  const [editDetails, setEditDetails] = createSignal();
  let renderCompVersion = 0;
  const [renderCompVersionList, setRenderCompVersionList] = createSignal([renderCompVersion]);
  const [userStyles, setUserStyles] = createSignal();
  const [tabIndex, setTabIndex] = createSignal(cellCtrl.getTabIndex());
  const [colId, setColId] = createSignal(cellCtrl.getColumnIdSanitised());
  const [selectionCheckboxId, setSelectionCheckboxId] = createSignal();
  const [includeSelection, setIncludeSelection] = createSignal(false);
  const [includeRowDrag, setIncludeRowDrag] = createSignal(false);
  const [includeDndSource, setIncludeDndSource] = createSignal(false);
  const forceWrapper = cellCtrl.isForceWrapper();
  let eCellWrapper;
  let eCellValue;
  const setECellValue = (val) => {
    eCellValue = val;
  };
  let eGui;
  let cellEditor = null;
  const setEditorRef = (popup, ref) => {
    cellEditor = ref;
    if (!cellEditor) {
      return;
    }
    checkCellEditorDeprecations(popup, cellEditor, cellCtrl);
    const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
    if (editingCancelledByUserComp) {
      setTimeout(() => {
        cellCtrl.stopEditing(true);
        cellCtrl.focusCell(true);
      });
    }
    const refAny = ref;
    if (refAny.afterGuiAttached) {
      setTimeout(() => refAny.afterGuiAttached(), 0);
    }
  };
  const setPopupEditorRef = (ref) => setEditorRef(true, ref);
  const setInlineEditorRef = (ref) => setEditorRef(false, ref);
  const cssClassManager = new CssClassManager(() => eGui);
  const showTools = createMemo(() => renderDetails() != null && (includeSelection() || includeDndSource() || includeRowDrag()));
  const showCellWrapper = createMemo(() => forceWrapper || showTools());
  const cellInstanceId = cellCtrl.getInstanceId();
  onMount(() => {
    if (!cellCtrl) {
      return;
    }
    const compProxy = {
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setUserStyles: (styles) => setUserStyles(styles),
      getFocusableElement: () => eGui,
      setIncludeSelection: (include) => setIncludeSelection(include),
      setIncludeRowDrag: (include) => setIncludeRowDrag(include),
      setIncludeDndSource: (include) => setIncludeDndSource(include),
      getCellEditor: () => cellEditor,
      getCellRenderer: () => null,
      getParentOfValue: () => eCellValue ? eCellValue : eGui,
      setRenderDetails: (compDetails, value, force) => {
        setRenderDetails({
          value,
          compDetails,
          force
        });
      },
      setEditDetails: (compDetails, popup, popupPosition) => {
        if (compDetails) {
          setEditDetails({
            compDetails,
            popup,
            popupPosition
          });
          if (!popup) {
            setRenderDetails(void 0);
          }
        } else {
          setEditDetails(void 0);
        }
      }
    };
    cellCtrl.setComp(compProxy, eGui, eCellWrapper, printLayout, editingRow);
  });
  createEffect(() => {
    const isEditing = !!editDetails();
    const isPopup = isEditing && !!editDetails()?.popup;
    cssClassManager.addOrRemoveCssClass("ag-cell-value", !showCellWrapper());
    cssClassManager.addOrRemoveCssClass("ag-cell-inline-editing", isEditing && !isPopup);
    cssClassManager.addOrRemoveCssClass("ag-cell-popup-editing", isEditing && isPopup);
    cssClassManager.addOrRemoveCssClass("ag-cell-not-inline-editing", !isEditing || isPopup);
    cellCtrl.getRowCtrl()?.setInlineEditingCss(isEditing);
  });
  let readyForRefresh = false;
  createEffect(() => {
    const details = renderDetails();
    const isJsCellRenderer = details != null && details.compDetails != null && !details.compDetails.componentFromFramework;
    if (!isJsCellRenderer) {
      readyForRefresh = false;
      return;
    }
    if (!readyForRefresh) {
      readyForRefresh = true;
      return;
    }
    {
      return;
    }
  });
  const eGuiFn = () => eGui;
  const bodyJsxFunc = () => [createComponent(For, {
    get each() {
      return renderCompVersionList();
    },
    children: () => renderDetails() && createComponent(showRenderDetails_default, {
      get showDetails() {
        return renderDetails();
      },
      cellInstanceId,
      get showCellWrapper() {
        return showCellWrapper();
      },
      cellCtrl,
      get includeDndSource() {
        return includeDndSource();
      },
      get includeRowDrag() {
        return includeRowDrag();
      },
      get includeSelection() {
        return includeSelection();
      },
      setSelectionCheckboxId,
      get showTools() {
        return showTools();
      },
      setECellValue
    })
  }), editDetails() && createComponent(showEditDetails_default, {
    get editDetails() {
      return editDetails();
    },
    cellCtrl,
    eGuiFn,
    setInlineRef: setInlineEditorRef,
    setPopupRef: setPopupEditorRef
  })];
  return ssr(_tmpl$11, ssrStyle(userStyles()), ssrAttribute("tabindex", escape(tabIndex(), true), false) + ssrAttribute("role", escape(cellCtrl.getCellAriaRole(), true), false) + ssrAttribute("col-id", escape(colId(), true), false), showCellWrapper() ? ssr(_tmpl$24, escape(bodyJsxFunc())) : escape(bodyJsxFunc()));
};
var cellComp_default = CellComp;

// src/grid/rows/rowComp.tsx
var _tmpl$12 = ['<div role="row" style="', '"', ">", "", "</div>"];
var maintainOrderOnColumns = (prev, next, domOrder) => {
  if (domOrder) {
    const res2 = {
      list: next,
      instanceIdMap: /* @__PURE__ */ new Map()
    };
    next.forEach((c) => res2.instanceIdMap.set(c.getInstanceId(), c));
    return res2;
  }
  const oldCellCtrls = [];
  const newCellCtrls = [];
  const newInstanceIdMap = /* @__PURE__ */ new Map();
  const tempMap = /* @__PURE__ */ new Map();
  next.forEach((c) => tempMap.set(c.getInstanceId(), c));
  prev.list.forEach((c) => {
    const instanceId = c.getInstanceId();
    if (tempMap.has(instanceId)) {
      oldCellCtrls.push(c);
      newInstanceIdMap.set(instanceId, c);
    }
  });
  next.forEach((c) => {
    const instanceId = c.getInstanceId();
    if (!prev.instanceIdMap.has(instanceId)) {
      newCellCtrls.push(c);
      newInstanceIdMap.set(instanceId, c);
    }
  });
  const res = {
    list: [...oldCellCtrls, ...newCellCtrls],
    instanceIdMap: newInstanceIdMap
  };
  return res;
};
var RowComp = (params) => {
  const {
    rowCtrl,
    containerType
  } = params;
  const [getRowIndex, setRowIndex] = createSignal();
  const [getRowId, setRowId] = createSignal();
  const [getRowBusinessKey, setRowBusinessKey] = createSignal();
  const [getTabIndex, setTabIndex] = createSignal(rowCtrl.getTabIndex());
  const [getUserStyles, setUserStyles] = createSignal();
  const [getCellCtrls, setCellCtrls] = createSignal({
    list: [],
    instanceIdMap: /* @__PURE__ */ new Map()
  });
  const [getFullWidthCompDetails, setFullWidthCompDetails] = createSignal();
  const [getDomOrder, setDomOrder] = createSignal(false);
  const [getTop, setTop] = createSignal(rowCtrl.getInitialRowTop(containerType));
  const [getTransform, setTransform] = createSignal(rowCtrl.getInitialTransform(containerType));
  let eGui;
  let fullWidthCompRef;
  createEffect(() => {
    const compDetails = getFullWidthCompDetails();
    if (!compDetails) {
      return;
    }
    let tryCount = 0;
    const trySetup = () => {
      eGui.firstChild;
      if (tryCount >= 10) {
        return;
      }
      tryCount++;
      setTimeout(trySetup, 0);
    };
    trySetup();
  });
  onMount(() => {
    if (!rowCtrl.isAlive()) {
      return;
    }
    const cssClassManager = new CssClassManager(() => eGui);
    const compProxy = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: (value) => setTop(value),
      setTransform: (value) => setTransform(value),
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setDomOrder: (domOrder) => setDomOrder(domOrder),
      setRowIndex: (value) => setRowIndex(value),
      setRowId: (value) => setRowId(value),
      setRowBusinessKey: (value) => setRowBusinessKey(value),
      setUserStyles: (styles) => setUserStyles(styles),
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (next) => setCellCtrls(maintainOrderOnColumns(getCellCtrls(), next, getDomOrder())),
      showFullWidth: (compDetails) => setFullWidthCompDetails(compDetails),
      getFullWidthCellRenderer: () => fullWidthCompRef,
      refreshFullWidth: (getUpdatedParams) => {
        {
          return false;
        }
      }
    };
    rowCtrl.setComp(compProxy, eGui, containerType);
    onCleanup(() => rowCtrl.unsetComp(containerType));
  });
  const getRowStyles = createMemo(() => {
    const res = {
      top: getTop(),
      transform: getTransform()
    };
    Object.assign(res, getUserStyles());
    return res;
  });
  const isShowCells = createMemo(() => getCellCtrls() != null);
  const isShowFullWidth = createMemo(() => getFullWidthCompDetails() != null);
  const showCellsJsx = () => createComponent(For, {
    get each() {
      return getCellCtrls().list;
    },
    children: (cellCtrl) => createComponent(cellComp_default, {
      cellCtrl,
      get editingRow() {
        return rowCtrl.isEditing();
      },
      get printLayout() {
        return rowCtrl.isPrintLayout();
      }
    })
  });
  const showFullWidthJsx = () => createComponent(userComp_default, {
    get compDetails() {
      return getFullWidthCompDetails();
    }
  });
  return ssr(_tmpl$12, ssrStyle(getRowStyles()), ssrAttribute("row-index", escape(getRowIndex(), true), false) + ssrAttribute("row-id", escape(getRowId(), true), false) + ssrAttribute("row-business-key", escape(getRowBusinessKey(), true), false) + ssrAttribute("tabindex", escape(getTabIndex(), true), false), isShowFullWidth() && escape(showFullWidthJsx()), isShowCells() && escape(showCellsJsx()));
};
var rowComp_default = RowComp;

// src/grid/rows/rowContainerComp.tsx
var _tmpl$13 = ["<div", ' role="rowgroup">', "</div>"];
var _tmpl$25 = ["<div", ' role="presentation" style="', '">', "</div>"];
var RowContainerComp = (props) => {
  const {
    context
  } = useContext(BeansContext);
  const [viewportHeight, setViewportHeight] = createSignal("");
  const [rowCtrlsOrdered, setRowCtrlsOrdered] = createSignal([]);
  const [rowCtrls, setRowCtrls] = createSignal([]);
  const [domOrder, setDomOrder] = createSignal(false);
  const {
    name
  } = props;
  const containerType = createMemo(() => getRowContainerTypeForName(name));
  let eViewport;
  let eContainer;
  const cssClasses = createMemo(() => RowContainerCtrl.getRowContainerCssClasses(name));
  const viewportClasses = createMemo(() => classesList(cssClasses().viewport));
  const containerClasses = createMemo(() => classesList(cssClasses().container));
  const centerTemplate = name === RowContainerName.CENTER || name === RowContainerName.TOP_CENTER || name === RowContainerName.BOTTOM_CENTER || name === RowContainerName.STICKY_TOP_CENTER;
  let rowCtrlsOrderedCopy = [];
  createEffect(() => {
    if (domOrder()) {
      setRowCtrlsOrdered(rowCtrls());
      return;
    }
    const prev = rowCtrlsOrderedCopy;
    const oldRows = prev.filter((r) => rowCtrls().indexOf(r) >= 0);
    const newRows = rowCtrls().filter((r) => oldRows.indexOf(r) < 0);
    const next = [...oldRows, ...newRows];
    setRowCtrlsOrdered(next);
    rowCtrlsOrderedCopy = next;
  });
  onMount(() => {
    const compProxy = {
      setViewportHeight,
      setRowCtrls: ({
        rowCtrls: rowCtrls2
      }) => setRowCtrls(rowCtrls2),
      setDomOrder: (domOrder2) => setDomOrder(domOrder2),
      setContainerWidth: (width) => {
      }
    };
    const ctrl = context.createBean(new RowContainerCtrl(name));
    onCleanup(() => context.destroyBean(ctrl));
    ctrl.setComp(compProxy, eContainer, eViewport);
  });
  const viewportStyle = createMemo(() => ({
    height: viewportHeight()
  }));
  const buildContainer = () => ssr(_tmpl$13, ssrAttribute("class", escape(containerClasses(), true), false), escape(createComponent(For, {
    get each() {
      return rowCtrlsOrdered();
    },
    children: (rowCtrl, i) => createComponent(rowComp_default, {
      rowCtrl,
      get containerType() {
        return containerType();
      }
    })
  })));
  return centerTemplate ? ssr(_tmpl$25, ssrAttribute("class", escape(viewportClasses(), true), false), ssrStyle(viewportStyle()), escape(buildContainer())) : buildContainer();
};
var rowContainerComp_default = RowContainerComp;

// src/grid/gridBodyComp.tsx
var _tmpl$14 = ["<div", ' role="treegrid"', ">", "<div", ' role="presentation" style="', '">', "", "", "", "</div><div", ' role="presentation"><div', ' role="presentation" style="', '">', "", "", "", "</div></div><div", ' role="presentation" style="', '">', "", "", "", "</div><div", ' role="presentation" style="', '">', "", "", "", "</div></div>"];
var GridBodyComp = () => {
  const {
    context,
    agStackComponentsRegistry,
    resizeObserverService
  } = useContext(BeansContext);
  const [getRowAnimationClass, setRowAnimationClass] = createSignal("");
  const [getAriaColCount, setAriaColCount] = createSignal(0);
  const [getAriaRowCount, setAriaRowCount] = createSignal(0);
  const [getTopHeight, setTopHeight] = createSignal(0);
  const [getBottomHeight, setBottomHeight] = createSignal(0);
  const [getStickyTopHeight, setStickyTopHeight] = createSignal("0px");
  const [getStickyTopTop, setStickyTopTop] = createSignal("0px");
  const [getStickyTopWidth, setStickyTopWidth] = createSignal("100%");
  const [getTopDisplay, setTopDisplay] = createSignal("");
  const [getBottomDisplay, setBottomDisplay] = createSignal("");
  const [getBodyViewportWidth, setBodyViewportWidth] = createSignal("");
  const [getMovingCss, setMovingCss] = createSignal(null);
  const [getForceVerticalScrollClass, setForceVerticalScrollClass] = createSignal(null);
  const [getTopAndBottomOverflowY, setTopAndBottomOverflowY] = createSignal(null);
  const [getCellSelectableCss, setCellSelectableCss] = createSignal(null);
  const [getLayoutClass, setLayoutClass] = createSignal("ag-layout-normal");
  let eRoot;
  let eTop;
  let eStickyTop;
  let eBody;
  let eBodyViewport;
  let eBottom;
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount(() => {
    if (!context) {
      return;
    }
    const newComp = (tag) => {
      const CompClass = agStackComponentsRegistry.getComponentClass(tag);
      const comp = context.createBean(new CompClass());
      onCleanup(() => context.destroyBean(comp));
      return comp;
    };
    eRoot.appendChild(newComp("AG-FAKE-HORIZONTAL-SCROLL").getGui());
    eRoot.appendChild(newComp("AG-OVERLAY-WRAPPER").getGui());
    eBody.appendChild(newComp("AG-FAKE-VERTICAL-SCROLL").getGui());
    const compProxy = {
      setRowAnimationCssOnBodyViewport: setRowAnimationClass,
      setColumnCount: setAriaColCount,
      setRowCount: setAriaRowCount,
      setTopHeight,
      setBottomHeight,
      setStickyTopHeight,
      setStickyTopTop,
      setStickyTopWidth,
      setTopDisplay,
      setBottomDisplay,
      setColumnMovingCss: setMovingCss,
      updateLayoutClasses: setLayoutClass,
      setAlwaysVerticalScrollClass: setForceVerticalScrollClass,
      setPinnedTopBottomOverflowY: setTopAndBottomOverflowY,
      setCellSelectableCss: (cssClass, flag) => setCellSelectableCss(flag ? cssClass : null),
      setBodyViewportWidth,
      registerBodyViewportResizeListener: (listener) => {
        const unsubscribeFromResize = resizeObserverService.observeResize(eBodyViewport, listener);
        destroyFuncs.push(() => unsubscribeFromResize());
      }
    };
    const ctrl = context.createBean(new GridBodyCtrl());
    onCleanup(() => context.destroyBean(ctrl));
    setTimeout(() => ctrl.setComp(compProxy, eRoot, eBodyViewport, eTop, eBottom, eStickyTop), 0);
  });
  const getRootClasses = createMemo(() => classesList("ag-root", "ag-unselectable", getMovingCss(), getLayoutClass()));
  const getBodyClasses = createMemo(() => classesList("ag-body", getLayoutClass()));
  const getBodyViewportClasses = createMemo(() => classesList("ag-body-viewport", getRowAnimationClass(), getLayoutClass(), getForceVerticalScrollClass(), getCellSelectableCss()));
  const getTopClasses = createMemo(() => classesList("ag-floating-top", getCellSelectableCss()));
  const getStickyTopClasses = createMemo(() => classesList("ag-sticky-top", getCellSelectableCss()));
  const getBottomClasses = createMemo(() => classesList("ag-floating-bottom", getCellSelectableCss()));
  const getTopStyle = createMemo(() => ({
    height: `${getTopHeight()}px`,
    "min-height": `${getTopHeight()}px`,
    display: getTopDisplay(),
    "overflow-y": getTopAndBottomOverflowY()
  }));
  const getStickyTopStyle = createMemo(() => ({
    height: getStickyTopHeight(),
    top: getStickyTopTop(),
    width: getStickyTopWidth()
  }));
  const getBottomStyle = createMemo(() => ({
    height: `${getBottomHeight()}px`,
    "min-height": `${getBottomHeight()}px`,
    display: getBottomDisplay(),
    "overflow-y": getTopAndBottomOverflowY()
  }));
  const getBodyViewportStyle = createMemo(() => ({
    width: getBodyViewportWidth()
  }));
  return ssr(_tmpl$14, ssrAttribute("class", escape(getRootClasses(), true), false), ssrAttribute("aria-colcount", escape(getAriaColCount(), true), false) + ssrAttribute("aria-rowcount", escape(getAriaRowCount(), true), false), escape(createComponent(gridHeaderComp_default, {})), ssrAttribute("class", escape(getTopClasses(), true), false), ssrStyle(getTopStyle()), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.TOP_LEFT;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.TOP_CENTER;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.TOP_RIGHT;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.TOP_FULL_WIDTH;
    }
  })), ssrAttribute("class", escape(getBodyClasses(), true), false), ssrAttribute("class", escape(getBodyViewportClasses(), true), false), ssrStyle(getBodyViewportStyle()), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.LEFT;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.CENTER;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.RIGHT;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.FULL_WIDTH;
    }
  })), ssrAttribute("class", escape(getStickyTopClasses(), true), false), ssrStyle(getStickyTopStyle()), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.STICKY_TOP_LEFT;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.STICKY_TOP_CENTER;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.STICKY_TOP_RIGHT;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.STICKY_TOP_FULL_WIDTH;
    }
  })), ssrAttribute("class", escape(getBottomClasses(), true), false), ssrStyle(getBottomStyle()), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.BOTTOM_LEFT;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.BOTTOM_CENTER;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.BOTTOM_RIGHT;
    }
  })), escape(createComponent(rowContainerComp_default, {
    get name() {
      return RowContainerName.BOTTOM_FULL_WIDTH;
    }
  })));
};
var gridBodyComp_default = GridBodyComp;
var _tmpl$15 = ['<div class="', '" role="presentation"', "></div>"];
var TabGuardComp = (props) => {
  const {
    children,
    eFocusableElement,
    onTabKeyDown,
    gridCtrl,
    forceFocusOutWhenTabGuardsAreEmpty
  } = props;
  const [tabIndex, setTabIndex] = createSignal();
  let eTopGuard;
  let eBottomGuard;
  let ctrl;
  const {
    context
  } = useContext(BeansContext);
  onMount(() => {
    const compProxy = {
      setTabIndex: (value) => value == null ? setTabIndex(void 0) : setTabIndex(parseInt(value, 10))
    };
    ctrl = context.createBean(new TabGuardCtrl({
      comp: compProxy,
      eTopGuard,
      eBottomGuard,
      eFocusableElement,
      onTabKeyDown,
      forceFocusOutWhenTabGuardsAreEmpty,
      focusInnerElement: (fromBottom) => gridCtrl.focusInnerElement(fromBottom)
    }));
    props.ref({
      forceFocusOutOfContainer(up) {
        ctrl.forceFocusOutOfContainer(up);
      }
    });
  });
  onCleanup(() => context.destroyBean(ctrl));
  return [ssr(_tmpl$15, `${escape(TabGuardClassNames.TAB_GUARD, true)} ${escape(TabGuardClassNames.TAB_GUARD_TOP, true)}`, ssrAttribute("tabindex", escape(tabIndex(), true), false)), children, ssr(_tmpl$15, `${escape(TabGuardClassNames.TAB_GUARD, true)} ${escape(TabGuardClassNames.TAB_GUARD_BOTTOM, true)}`, ssrAttribute("tabindex", escape(tabIndex(), true), false))];
};
var tabGuardComp_default = TabGuardComp;

// src/grid/gridComp.tsx
var _tmpl$16 = ["<div", ' style="', '"><div', ">", "</div></div>"];
var GridComp = (props) => {
  const [rtlClass, setRtlClass] = createSignal("");
  const [keyboardFocusClass, setKeyboardFocusClass] = createSignal("");
  const [layoutClass, setLayoutClass] = createSignal("");
  const [cursor, setCursor] = createSignal(null);
  const [userSelect, setUserSelect] = createSignal(null);
  const [initialised, setInitialised] = createSignal(false);
  const {
    context
  } = props;
  const beans = context.getBean("beans");
  let eGui;
  let gridCtrl;
  const onTabKeyDown = () => void 0;
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount(() => {
    gridCtrl = context.createBean(new GridCtrl());
    destroyFuncs.push(() => context.destroyBean(gridCtrl));
    const compProxy = {
      destroyGridUi: () => {
      },
      // do nothing, as framework users destroy grid by removing the comp
      setRtlClass,
      forceFocusOutOfContainer: (up) => {
      },
      updateLayoutClasses: setLayoutClass,
      getFocusableContainers: () => {
        const els = [];
        const gridBodyCompEl = eGui.querySelector(".ag-root");
        const sideBarEl = eGui.querySelector(".ag-side-bar:not(.ag-hidden)");
        if (gridBodyCompEl) {
          els.push(gridBodyCompEl);
        }
        if (sideBarEl) {
          els.push(sideBarEl);
        }
        return els;
      },
      setCursor,
      setUserSelect
    };
    gridCtrl.setComp(compProxy, eGui, eGui);
    setInitialised(true);
  });
  const cssClasses = createMemo(() => classesList("ag-root-wrapper", rtlClass(), keyboardFocusClass(), layoutClass(), props.class));
  const bodyCssClasses = createMemo(() => classesList("ag-root-wrapper-body", "ag-focus-managed", layoutClass()));
  const topStyle = createMemo(() => ({
    userSelect: userSelect != null ? userSelect() : "",
    WebkitUserSelect: userSelect != null ? userSelect() : "",
    cursor: cursor != null ? cursor() : ""
  }));
  return ssr(_tmpl$16, ssrAttribute("class", escape(cssClasses(), true), false), ssrStyle(topStyle()), ssrAttribute("class", escape(bodyCssClasses(), true), false), initialised() && escape(
    // we wait for initialised before rending the children, so GridComp has created and registered with it's
    // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
    // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
    // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
    // hangs the UI)
    createComponent(BeansContext.Provider, {
      value: beans,
      get children() {
        return createComponent(tabGuardComp_default, {
          eFocusableElement: eGui,
          onTabKeyDown,
          gridCtrl,
          forceFocusOutWhenTabGuardsAreEmpty: true,
          get children() {
            return createComponent(gridBodyComp_default, {});
          }
        });
      }
    })
  ));
};
var gridComp_default = GridComp;

// src/grid/agGridSolid.tsx
var _tmpl$17 = ['<div style="', '">', "", "</div>"];
var AgGridSolid = function(props) {
  let eGui;
  let api;
  const [context, setContext] = createSignal();
  const [getPortals, setPortals] = createSignal([]);
  const destroyFuncs = [];
  onCleanup(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  const propsCopy = {};
  Object.keys(props).forEach((key) => propsCopy[key] = props[key]);
  createEffect(() => {
    const keys = Object.keys(props);
    const changes = {};
    let changesExist = false;
    keys.forEach((key) => {
      const currentValue = props[key];
      const previousValue = propsCopy[key];
      if (previousValue !== currentValue) {
        changes[key] = currentValue;
        propsCopy[key] = currentValue;
        changesExist = true;
      }
    });
    if (changesExist) {
      ComponentUtil.processOnChange(changes, api);
    }
  });
  onMount(() => {
    const modules = props.modules || [];
    const portalManager = {
      addPortal: (info) => {
        setPortals([...getPortals(), info]);
      },
      removePortal: (info) => {
        setPortals(getPortals().filter((item) => item != info));
      }
    };
    const gridParams = {
      providedBeanInstances: {
        frameworkComponentWrapper: new SolidCompWrapperFactory(portalManager)
      },
      modules,
      frameworkOverrides: new SolidFrameworkOverrides()
    };
    const gridOptions = ComponentUtil.combineAttributesAndGridOptions(props.gridOptions, props);
    const createUiCallback = (context2) => {
      setContext(context2);
      const ctrlsService = context2.getBean(CtrlsService.NAME);
      ctrlsService.whenReady(() => {
        const refCallback = props.ref && props.ref;
        if (refCallback) {
          const gridRef = {
            api,
            columnApi: new ColumnApi(api)
          };
          refCallback(gridRef);
        }
        destroyFuncs.push(() => api.destroy());
      });
    };
    const acceptChangesCallback = () => {
    };
    const gridCoreCreator = new GridCoreCreator();
    api = gridCoreCreator.create(
      // @ts-ignore
      eGui,
      gridOptions,
      createUiCallback,
      acceptChangesCallback,
      gridParams
    );
  });
  return ssr(_tmpl$17, "height:100%", context() && escape(createComponent(gridComp_default, {
    get ["class"]() {
      return props.class;
    },
    get context() {
      return context();
    }
  })), escape(createComponent(For, {
    get each() {
      return getPortals();
    },
    children: (info, i) => createComponent(Portal, {
      get mount() {
        return info.mount;
      },
      get children() {
        return createComponent(info.SolidClass, mergeProps(() => info.props));
      }
    })
  })));
};
var agGridSolid_default = AgGridSolid;

// src/index.tsx
var src_default = agGridSolid_default;

export { src_default as default };
