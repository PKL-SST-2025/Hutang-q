// src/grid/agGridSolid.tsx
import {
  ColumnApi,
  ComponentUtil,
  CtrlsService,
  GridCoreCreator
} from "ag-grid-community";
import { createEffect as createEffect6, createSignal as createSignal15, For as For6, onCleanup as onCleanup12, onMount as onMount15 } from "solid-js";
import { Portal as Portal2 } from "solid-js/web";

// src/grid/core/solidCompWrapperFactory.tsx
import {
  BaseComponentWrapper
} from "ag-grid-community";

// src/grid/core/solidCompWrapper.tsx
var SolidCompWrapper = class {
  eGui;
  SolidCompClass;
  portalManager;
  portalInfo;
  instance;
  constructor(SolidCompClass, portalManager) {
    this.SolidCompClass = SolidCompClass;
    this.portalManager = portalManager;
  }
  init(props) {
    this.eGui = document.createElement("div");
    this.eGui.className = "ag-solid-container";
    this.portalInfo = {
      mount: this.eGui,
      SolidClass: this.SolidCompClass,
      props,
      ref: (instance) => {
        this.instance = instance;
      }
    };
    this.portalManager.addPortal(this.portalInfo);
  }
  destroy() {
    this.portalInfo && this.portalManager.removePortal(this.portalInfo);
  }
  getGui() {
    return this.eGui;
  }
  hasMethod(name) {
    return this.instance[name] != null;
  }
  getFrameworkComponentInstance() {
    return this.instance;
  }
  callMethod(name, args) {
    return this.instance[name].apply(this.instance, args);
  }
  addMethod(name, callback) {
    this[name] = callback;
  }
};

// src/grid/core/solidCompWrapperFactory.tsx
var SolidCompWrapperFactory = class extends BaseComponentWrapper {
  portalManager;
  constructor(portalManager) {
    super();
    this.portalManager = portalManager;
  }
  createWrapper(SolidComponentClass) {
    return new SolidCompWrapper(SolidComponentClass, this.portalManager);
  }
};

// src/grid/core/solidFrameworkOverrides.tsx
import { VanillaFrameworkOverrides } from "ag-grid-community";

// src/grid/cellRenderer/detailCellRenderer.tsx
import { createMemo, createSignal, onMount, useContext } from "solid-js";

// src/grid/core/beansContext.tsx
import { createContext } from "solid-js";
var BeansContext = createContext({});

// src/grid/core/utils.tsx
var classesList = (...list) => {
  const filtered = list.filter((s) => s != null && s !== "");
  return filtered.join(" ");
};
var CssClasses = class _CssClasses {
  classesMap = {};
  constructor(...initialClasses) {
    initialClasses.forEach((className) => {
      this.classesMap[className] = true;
    });
  }
  setClass(className, on) {
    const nothingHasChanged = !!this.classesMap[className] == on;
    if (nothingHasChanged) {
      return this;
    }
    const res = new _CssClasses();
    res.classesMap = { ...this.classesMap };
    res.classesMap[className] = on;
    return res;
  }
  toString() {
    const res = Object.keys(this.classesMap).filter((key) => this.classesMap[key]).join(" ");
    return res;
  }
};

// src/grid/cellRenderer/detailCellRenderer.tsx
var DetailCellRenderer = (props) => {
  const {
    ctrlsFactory,
    context,
    gridOptionsService,
    resizeObserverService,
    clientSideRowModel,
    serverSideRowModel
  } = useContext(BeansContext);
  const [getCssClasses, setCssClasses] = createSignal(new CssClasses());
  const [getGridCssClasses, setGridCssClasses] = createSignal(new CssClasses());
  const [getDetailGridOptions, setDetailGridOptions] = createSignal();
  const [getDetailRowData, setDetailRowData] = createSignal();
  let ctrl;
  let eGuiRef;
  const getCssClassesStr = createMemo(() => getCssClasses().toString() + " ag-details-row");
  const getGridCssClassesStr = createMemo(
    () => getGridCssClasses().toString() + " ag-details-grid"
  );
  props.ref(() => ({
    // force new instance when grid tries to refresh
    refresh() {
      return ctrl.refresh();
    }
  }));
  onMount(() => {
    if (props.template && typeof props.template === "string") {
    }
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      addOrRemoveDetailGridCssClass: (name, on) => setGridCssClasses(getGridCssClasses().setClass(name, on)),
      setDetailGrid: (gridOptions) => setDetailGridOptions(gridOptions),
      setRowData: (rowData) => setDetailRowData(rowData),
      getGui: () => eGuiRef
    };
    ctrl = ctrlsFactory.getInstance("detailCellRenderer");
    if (!ctrl) {
      return;
    }
    context.createBean(ctrl);
    ctrl.init(compProxy, props);
    let resizeObserverDestroyFunc;
    if (gridOptionsService.get("detailRowAutoHeight")) {
      const checkRowSizeFunc = () => {
        if (eGuiRef == null) {
          return;
        }
        const clientHeight = eGuiRef.clientHeight;
        if (clientHeight != null && clientHeight > 0) {
          const updateRowHeightFunc = () => {
            props.node.setRowHeight(clientHeight);
            if (clientSideRowModel) {
              clientSideRowModel.onRowHeightChanged();
            } else if (serverSideRowModel) {
              serverSideRowModel.onRowHeightChanged();
            }
          };
          setTimeout(updateRowHeightFunc, 0);
        }
      };
      resizeObserverDestroyFunc = resizeObserverService.observeResize(eGuiRef, checkRowSizeFunc);
      checkRowSizeFunc();
    }
    return () => {
      context.destroyBean(ctrl);
      if (resizeObserverDestroyFunc) {
        resizeObserverDestroyFunc();
      }
    };
  });
  const setRef = (ref) => {
    ctrl.registerDetailWithMaster(ref.api, ref.columnApi);
  };
  return <div class={getCssClassesStr()} ref={eGuiRef}>
      {getDetailGridOptions() && <AgGridSolid_default
    class={getGridCssClassesStr()}
    {...getDetailGridOptions()}
    rowData={getDetailRowData()}
    ref={setRef}
  />}
    </div>;
};
var detailCellRenderer_default = DetailCellRenderer;

// src/grid/cellRenderer/groupCellRenderer.tsx
import {
  GroupCellRendererCtrl,
  _
} from "ag-grid-community";
import { createMemo as createMemo3, createSignal as createSignal2, onMount as onMount2, useContext as useContext3 } from "solid-js";

// src/grid/userComps/userComp.tsx
import { createMemo as createMemo2 } from "solid-js";

// src/grid/userComps/jsUserComp.tsx
import { onCleanup, useContext as useContext2 } from "solid-js";
var JsUserComp = (p) => {
  const { context } = useContext2(BeansContext);
  const promise = p.compDetails.newAgStackInstance();
  if (!promise) {
    return <></>;
  }
  const comp = promise.resolveNow(null, (x) => x);
  if (!comp) {
    return <></>;
  }
  p.ref && p.ref(comp);
  const gui = comp.getGui();
  onCleanup(() => {
    comp && context.destroyBean(comp);
    p.ref && p.ref(void 0);
  });
  return <>{gui}</>;
};
var JsUserComp_default = JsUserComp;

// src/grid/userComps/solidUserComp.tsx
import { onCleanup as onCleanup2 } from "solid-js";
var SolidUserComp = (props) => {
  const SolidClass = props.compDetails.componentClass;
  let refSet = false;
  const setRef = (ref) => {
    if (!props.ref) {
      return;
    }
    props.ref(ref);
    refSet = true;
  };
  onCleanup2(() => {
    if (refSet) {
      props.ref && props.ref(void 0);
    }
  });
  return <SolidClass ref={setRef} {...props.compDetails.params} />;
};
var SolidUserComp_default = SolidUserComp;

// src/grid/userComps/userComp.tsx
var UserComp = (p) => {
  const showSolidComp = createMemo2(() => {
    const details = p.compDetails;
    if (!details) {
      return false;
    }
    return details.componentFromFramework;
  });
  const showJsComp = createMemo2(() => {
    const details = p.compDetails;
    if (!details) {
      return false;
    }
    return !details.componentFromFramework;
  });
  return <>
      {showSolidComp() && <SolidUserComp_default compDetails={p.compDetails} ref={p.ref} />}
      {showJsComp() && <JsUserComp_default compDetails={p.compDetails} ref={p.ref} />}
    </>;
};
var UserComp_default = UserComp;

// src/grid/cellRenderer/groupCellRenderer.tsx
var GroupCellRenderer = (props) => {
  const context = useContext3(BeansContext).context;
  let eGui;
  let eValueRef;
  let eCheckboxRef;
  let eExpandedRef;
  let eContractedRef;
  let role = "gridcell";
  const [getInnerCompDetails, setInnerCompDetails] = createSignal2();
  const [getChildCount, setChildCount] = createSignal2();
  const [getValue, setValue] = createSignal2();
  const [getCssClasses, setCssClasses] = createSignal2(new CssClasses());
  const [getExpandedCssClasses, setExpandedCssClasses] = createSignal2(
    new CssClasses("ag-hidden")
  );
  const [getContractedCssClasses, setContractedCssClasses] = createSignal2(
    new CssClasses("ag-hidden")
  );
  const [getCheckboxCssClasses, setCheckboxCssClasses] = createSignal2(
    new CssClasses("ag-invisible")
  );
  props.ref(() => ({
    // force new instance when grid tries to refresh
    refresh() {
      return false;
    }
  }));
  onMount2(() => {
    const compProxy = {
      setInnerRenderer: (details, valueToDisplay) => {
        setInnerCompDetails(details);
        const escapedValue = _.escapeString(valueToDisplay, true);
        setValue(escapedValue);
      },
      setChildCount: (count) => setChildCount(count),
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setContractedDisplayed: (displayed) => setContractedCssClasses(getContractedCssClasses().setClass("ag-hidden", !displayed)),
      setExpandedDisplayed: (displayed) => setExpandedCssClasses(getExpandedCssClasses().setClass("ag-hidden", !displayed)),
      setCheckboxVisible: (visible) => setCheckboxCssClasses(getCheckboxCssClasses().setClass("ag-invisible", !visible))
    };
    const ctrl = context.createBean(new GroupCellRendererCtrl());
    ctrl.init(
      compProxy,
      eGui,
      eCheckboxRef,
      eExpandedRef,
      eContractedRef,
      GroupCellRenderer,
      props
    );
    eGui.setAttribute("role", ctrl.getCellAriaRole());
    role = ctrl.getCellAriaRole();
    return () => {
      context.destroyBean(ctrl);
    };
  });
  const getClassName = createMemo3(() => `ag-cell-wrapper ${getCssClasses().toString()}`);
  const getExpandedClassName = createMemo3(
    () => `ag-group-expanded ${getExpandedCssClasses().toString()}`
  );
  const getContractedClassName = createMemo3(
    () => `ag-group-contracted ${getContractedCssClasses().toString()}`
  );
  const getCheckboxClassName = createMemo3(
    () => `ag-group-checkbox ${getCheckboxCssClasses().toString()}`
  );
  const isShowUserComp = () => getInnerCompDetails() != null;
  const isShowValue = () => getInnerCompDetails() == null && getValue() != null;
  return <span class={getClassName()} ref={eGui} {...!props.colDef ? { role } : {}}>
      <span class={getExpandedClassName()} ref={eExpandedRef} />
      <span class={getContractedClassName()} ref={eContractedRef} />
      <span class={getCheckboxClassName()} ref={eCheckboxRef} />
      <span class="ag-group-value" ref={eValueRef}>
        {isShowUserComp() && <UserComp_default compDetails={getInnerCompDetails()} />}
        {isShowValue() && <>{getValue()}</>}
      </span>
      <span class="ag-group-child-count">{getChildCount()}</span>
    </span>;
};
var groupCellRenderer_default = GroupCellRenderer;

// src/grid/core/solidFrameworkOverrides.tsx
var SolidFrameworkOverrides = class extends VanillaFrameworkOverrides {
  constructor() {
    super("solid");
  }
  frameworkComponents = {
    agGroupCellRenderer: groupCellRenderer_default,
    agGroupRowRenderer: groupCellRenderer_default,
    agDetailCellRenderer: detailCellRenderer_default
  };
  frameworkComponent(name) {
    return this.frameworkComponents[name];
  }
  isFrameworkComponent(comp) {
    if (!comp) {
      return false;
    }
    const prototype = comp.prototype;
    const isJsComp = prototype && "getGui" in prototype;
    return !isJsComp;
  }
};

// src/grid/gridComp.tsx
import { GridCtrl as GridCtrl2 } from "ag-grid-community";
import { createMemo as createMemo16, createSignal as createSignal14, onCleanup as onCleanup11, onMount as onMount14 } from "solid-js";

// src/grid/gridBodyComp.tsx
import { GridBodyCtrl, RowContainerName as RowContainerName2 } from "ag-grid-community";
import { createMemo as createMemo15, createSignal as createSignal12, onCleanup as onCleanup9, onMount as onMount12, useContext as useContext10 } from "solid-js";

// src/grid/header/gridHeaderComp.tsx
import { GridHeaderCtrl } from "ag-grid-community";
import { createMemo as createMemo9, createSignal as createSignal8, onCleanup as onCleanup4, onMount as onMount8, useContext as useContext6 } from "solid-js";

// src/grid/header/headerRowContainerComp.tsx
import {
  HeaderRowContainerCtrl
} from "ag-grid-community";
import {
  createMemo as createMemo8,
  createSignal as createSignal7,
  For as For2,
  onCleanup as onCleanup3,
  onMount as onMount7,
  useContext as useContext5
} from "solid-js";

// src/grid/header/headerRowComp.tsx
import {
  HeaderRowType,
  _ as _2
} from "ag-grid-community";
import { createMemo as createMemo7, createSignal as createSignal6, For, onMount as onMount6, useContext as useContext4 } from "solid-js";

// src/grid/header/headerCellComp.tsx
import {
  CssClassManager
} from "ag-grid-community";
import { createMemo as createMemo4, createSignal as createSignal3, onMount as onMount3 } from "solid-js";
var HeaderCellComp = (props) => {
  const { ctrl } = props;
  const [getWidth, setWidth] = createSignal3();
  const [getColId, setColId] = createSignal3(ctrl.getColId());
  const [getAriaSort, setAriaSort] = createSignal3();
  const [getUserCompDetails, setUserCompDetails] = createSignal3();
  let eGui;
  let eResize;
  let eHeaderCompWrapper;
  let userComp;
  const setRef = (ref) => {
    userComp = ref;
  };
  const cssClassManager = new CssClassManager(() => eGui);
  onMount3(() => {
    const compProxy = {
      setWidth: (width) => setWidth(width),
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setAriaSort: (sort) => setAriaSort(sort),
      setUserCompDetails: (compDetails) => setUserCompDetails(compDetails),
      getUserCompInstance: () => userComp
    };
    ctrl.setComp(compProxy, eGui, eResize, eHeaderCompWrapper);
    const selectAllGui = ctrl.getSelectAllGui();
    eResize.insertAdjacentElement("afterend", selectAllGui);
    ctrl.setDragSource(eGui);
  });
  const style = createMemo4(() => ({ width: getWidth() }));
  return <div
    ref={eGui}
    class="ag-header-cell"
    style={style()}
    col-id={getColId()}
    aria-sort={getAriaSort()}
    role="columnheader"
  >
      <div ref={eResize} class="ag-header-cell-resize" role="presentation" />
      <div ref={eHeaderCompWrapper} class="ag-header-cell-comp-wrapper" role="presentation">
        {getUserCompDetails() && <UserComp_default compDetails={getUserCompDetails()} ref={setRef} />}
      </div>
    </div>;
};
var HeaderCellComp_default = HeaderCellComp;

// src/grid/header/headerFilterCellComp.tsx
import {
  AgPromise
} from "ag-grid-community";
import { createMemo as createMemo5, createSignal as createSignal4, onMount as onMount4 } from "solid-js";
var HeaderFilterCellComp = (props) => {
  const [getCssClasses, setCssClasses] = createSignal4(new CssClasses());
  const [getCssBodyClasses, setBodyCssClasses] = createSignal4(new CssClasses());
  const [getCssButtonWrapperClasses, setButtonWrapperCssClasses] = createSignal4(
    new CssClasses()
  );
  const [getButtonWrapperAriaHidden, setButtonWrapperAriaHidden] = createSignal4(
    "false"
  );
  const [getWidth, setWidth] = createSignal4();
  const [getUserCompDetails, setUserCompDetails] = createSignal4();
  let eGui;
  let eFloatingFilterBody;
  let eButtonWrapper;
  let eButtonShowMainFilter;
  let alreadyResolved = false;
  let userCompResolve;
  let userCompPromise;
  onMount4(() => {
    userCompPromise = new AgPromise((resolve) => {
      userCompResolve = resolve;
    });
  });
  const setRef = (value) => {
    if (alreadyResolved) {
      return;
    }
    if (value == null) {
      return;
    }
    userCompResolve && userCompResolve(value);
    alreadyResolved = true;
  };
  const { ctrl } = props;
  onMount4(() => {
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses((prev) => prev.setClass(name, on)),
      addOrRemoveBodyCssClass: (name, on) => setBodyCssClasses((prev) => prev.setClass(name, on)),
      setButtonWrapperDisplayed: (displayed) => {
        setButtonWrapperCssClasses((prev) => prev.setClass("ag-hidden", !displayed));
        setButtonWrapperAriaHidden(!displayed ? "true" : "false");
      },
      setWidth: (width) => setWidth(width),
      setCompDetails: (compDetails) => setUserCompDetails(compDetails),
      getFloatingFilterComp: () => userCompPromise,
      setMenuIcon: (eIcon) => eButtonShowMainFilter.appendChild(eIcon)
    };
    ctrl.setComp(compProxy, eGui, eButtonShowMainFilter, eFloatingFilterBody);
  });
  const getStyle = createMemo5(() => ({
    width: getWidth()
  }));
  const getCssClassesString = createMemo5(
    () => "ag-header-cell ag-floating-filter " + getCssClasses().toString()
  );
  const getBodyCssClassesString = createMemo5(() => getCssBodyClasses().toString());
  const getButtonWrapperCssClassesString = createMemo5(
    () => "ag-floating-filter-button " + getCssButtonWrapperClasses().toString()
  );
  return <div ref={eGui} class={getCssClassesString()} style={getStyle()} role="gridcell">
      <div ref={eFloatingFilterBody} class={getBodyCssClassesString()} role="presentation">
        {getUserCompDetails() && <UserComp_default compDetails={getUserCompDetails()} ref={setRef} />}
      </div>
      <div
    ref={eButtonWrapper}
    aria-hidden={getButtonWrapperAriaHidden()}
    class={getButtonWrapperCssClassesString()}
    role="presentation"
  >
        <button
    ref={eButtonShowMainFilter}
    type="button"
    class="ag-button ag-floating-filter-button-button"
    tabIndex={-1}
  />
      </div>
    </div>;
};
var HeaderFilterCellComp_default = HeaderFilterCellComp;

// src/grid/header/headerGroupCellComp.tsx
import { createEffect, createMemo as createMemo6, createSignal as createSignal5, onMount as onMount5 } from "solid-js";
var HeaderGroupCellComp = (props) => {
  const { ctrl } = props;
  const [getCssClasses, setCssClasses] = createSignal5(new CssClasses());
  const [getCssResizableClasses, setResizableCssClasses] = createSignal5(
    new CssClasses()
  );
  const [getResizableAriaHidden, setResizableAriaHidden] = createSignal5("false");
  const [getWidth, setWidth] = createSignal5();
  const [getColId, setColId] = createSignal5(ctrl.getColId());
  const [getAriaExpanded, setAriaExpanded] = createSignal5();
  const [getUserCompDetails, setUserCompDetails] = createSignal5();
  let eGui;
  let eResize;
  onMount5(() => {
    const compProxy = {
      setWidth: (width) => setWidth(width),
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setUserCompDetails: (compDetails) => setUserCompDetails(compDetails),
      setResizableDisplayed: (displayed) => {
        setResizableCssClasses((prev) => prev.setClass("ag-hidden", !displayed));
        setResizableAriaHidden(!displayed ? "true" : "false");
      },
      setAriaExpanded: (expanded) => setAriaExpanded(expanded)
    };
    ctrl.setComp(compProxy, eGui, eResize);
  });
  createEffect(() => {
    const userCompDetails = getUserCompDetails();
    if (userCompDetails == null) {
      return;
    }
    ctrl.setDragSource(eGui);
  });
  const style = createMemo6(() => ({
    width: getWidth()
  }));
  const getClassName = createMemo6(() => "ag-header-group-cell " + getCssClasses().toString());
  const getResizableClassName = createMemo6(
    () => "ag-header-cell-resize " + getCssResizableClasses().toString()
  );
  return <div
    ref={eGui}
    class={getClassName()}
    style={style()}
    col-id={getColId()}
    role="columnheader"
    aria-expanded={getAriaExpanded()}
  >
      {getUserCompDetails() && <UserComp_default compDetails={getUserCompDetails()} />}

      <div
    ref={eResize}
    aria-hidden={getResizableAriaHidden()}
    class={getResizableClassName()}
  />
    </div>;
};
var HeaderGroupCellComp_default = HeaderGroupCellComp;

// src/grid/header/headerRowComp.tsx
var HeaderRowComp = (props) => {
  const { gridOptionsService } = useContext4(BeansContext);
  const { ctrl } = props;
  const [getHeight, setHeight] = createSignal6();
  const [getTop, setTop] = createSignal6();
  const [getWidth, setWidth] = createSignal6();
  const [getAriaRowIndex, setAriaRowIndex] = createSignal6(ctrl.getAriaRowIndex());
  const [getCellCtrls, setCellCtrls] = createSignal6([]);
  let eGui;
  const setCellCtrlsMaintainOrder = (next) => {
    const prev = getCellCtrls();
    const isEnsureDomOrder = gridOptionsService.get("ensureDomOrder");
    const isPrintLayout = gridOptionsService.isDomLayout("print");
    if (isEnsureDomOrder || isPrintLayout) {
      return next;
    }
    const prevMap = _2.mapById(prev, (c) => c.getInstanceId());
    const nextMap = _2.mapById(next, (c) => c.getInstanceId());
    const oldCtrlsWeAreKeeping = prev.filter((c) => nextMap.has(c.getInstanceId()));
    const newCtrls = next.filter((c) => !prevMap.has(c.getInstanceId()));
    const nextOrderMaintained = [...oldCtrlsWeAreKeeping, ...newCtrls];
    setCellCtrls(nextOrderMaintained);
  };
  onMount6(() => {
    const compProxy = {
      setHeight: (height) => setHeight(height),
      setTop: (top) => setTop(top),
      setHeaderCtrls: (ctrls) => setCellCtrlsMaintainOrder(ctrls),
      setWidth: (width) => setWidth(width)
    };
    ctrl.setComp(compProxy);
  });
  const style = createMemo7(() => ({
    height: getHeight(),
    top: getTop(),
    width: getWidth()
  }));
  const cssClasses = ctrl.getHeaderRowClass();
  const createCellJsx = (cellCtrl) => {
    switch (ctrl.getType()) {
      case HeaderRowType.COLUMN_GROUP:
        return <HeaderGroupCellComp_default ctrl={cellCtrl} />;
      case HeaderRowType.FLOATING_FILTER:
        return <HeaderFilterCellComp_default ctrl={cellCtrl} />;
      default:
        return <HeaderCellComp_default ctrl={cellCtrl} />;
    }
  };
  return <div
    ref={eGui}
    class={cssClasses}
    role="row"
    style={style()}
    aria-rowindex={getAriaRowIndex()}
  >
      <For each={getCellCtrls()}>{(cellCtrl, i) => createCellJsx(cellCtrl)}</For>
    </div>;
};
var HeaderRowComp_default = HeaderRowComp;

// src/grid/header/headerRowContainerComp.tsx
var HeaderRowContainerComp = (props) => {
  const [getCssClasses, setCssClasses] = createSignal7(new CssClasses());
  const [getAriaHidden, setAriaHidden] = createSignal7(false);
  const [getCenterContainerWidth, setCenterContainerWidth] = createSignal7();
  const [getPinnedContainerWidth, setPinnedContainerWidth] = createSignal7();
  const [getHeaderRowCtrls, setHeaderRowCtrls] = createSignal7([]);
  const { context } = useContext5(BeansContext);
  let eGui;
  const pinnedLeft = props.pinned === "left";
  const pinnedRight = props.pinned === "right";
  const centre = !pinnedLeft && !pinnedRight;
  const destroyFuncs = [];
  onCleanup3(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount7(() => {
    const compProxy = {
      setDisplayed: (displayed) => {
        setCssClasses(getCssClasses().setClass("ag-hidden", !displayed));
        setAriaHidden(!displayed);
      },
      setCtrls: (ctrls) => setHeaderRowCtrls(ctrls),
      // centre only
      setCenterWidth: (width) => setCenterContainerWidth(width),
      setViewportScrollLeft: (left) => eGui.scrollLeft = left,
      // pinned only
      setPinnedContainerWidth: (width) => setPinnedContainerWidth(width)
    };
    const ctrl = context.createBean(new HeaderRowContainerCtrl(props.pinned));
    ctrl.setComp(compProxy, eGui);
    destroyFuncs.push(() => context.destroyBean(ctrl));
  });
  const getClassName = createMemo8(() => getCssClasses().toString());
  const insertRowsJsx = () => <For2 each={getHeaderRowCtrls()}>{(ctrl) => <HeaderRowComp_default ctrl={ctrl} />}</For2>;
  const eCenterContainerStyle = createMemo8(() => ({
    width: getCenterContainerWidth()
  }));
  const ePinnedStyle = createMemo8(() => ({
    width: getPinnedContainerWidth(),
    "min-width": getPinnedContainerWidth(),
    "max-width": getPinnedContainerWidth()
  }));
  return <>
      {pinnedLeft && <div
    ref={eGui}
    class={"ag-pinned-left-header " + getClassName()}
    aria-hidden={getAriaHidden()}
    role="rowgroup"
    style={ePinnedStyle()}
  >
          {insertRowsJsx()}
        </div>}
      {pinnedRight && <div
    ref={eGui}
    class={"ag-pinned-right-header " + getClassName()}
    aria-hidden={getAriaHidden()}
    role="rowgroup"
    style={ePinnedStyle()}
  >
          {insertRowsJsx()}
        </div>}
      {centre && <div ref={eGui} class={"ag-header-viewport " + getClassName()} role="presentation">
          <div class="ag-header-container" role="rowgroup" style={eCenterContainerStyle()}>
            {insertRowsJsx()}
          </div>
        </div>}
    </>;
};
var HeaderRowContainerComp_default = HeaderRowContainerComp;

// src/grid/header/gridHeaderComp.tsx
var GridHeaderComp = () => {
  const [getCssClasses, setCssClasses] = createSignal8(new CssClasses());
  const [getHeight, setHeight] = createSignal8();
  const { context } = useContext6(BeansContext);
  let eGui;
  const destroyFuncs = [];
  onCleanup4(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount8(() => {
    const compProxy = {
      addOrRemoveCssClass: (name, on) => setCssClasses(getCssClasses().setClass(name, on)),
      setHeightAndMinHeight: (height) => setHeight(height)
    };
    const ctrl = context.createBean(new GridHeaderCtrl());
    ctrl.setComp(compProxy, eGui, eGui);
    destroyFuncs.push(() => context.destroyBean(ctrl));
  });
  const className = createMemo9(() => {
    let res = getCssClasses().toString();
    return "ag-header " + res;
  });
  const style = createMemo9(() => ({
    height: getHeight(),
    "min-height": getHeight()
  }));
  return <div ref={eGui} class={className()} style={style()} role="presentation">
      <HeaderRowContainerComp_default pinned={"left"} />
      <HeaderRowContainerComp_default pinned={null} />
      <HeaderRowContainerComp_default pinned={"right"} />
    </div>;
};
var GridHeaderComp_default = GridHeaderComp;

// src/grid/rows/rowContainerComp.tsx
import {
  getRowContainerTypeForName,
  RowContainerCtrl,
  RowContainerName
} from "ag-grid-community";
import {
  createEffect as createEffect5,
  createMemo as createMemo14,
  createSignal as createSignal11,
  For as For5,
  onCleanup as onCleanup8,
  onMount as onMount11,
  useContext as useContext9
} from "solid-js";

// src/grid/rows/rowComp.tsx
import {
  CssClassManager as CssClassManager3
} from "ag-grid-community";
import { createEffect as createEffect4, createMemo as createMemo13, createSignal as createSignal10, For as For4, onCleanup as onCleanup7, onMount as onMount10 } from "solid-js";

// src/grid/cells/cellComp.tsx
import {
  CssClassManager as CssClassManager2,
  _ as _3
} from "ag-grid-community";
import { createEffect as createEffect3, createMemo as createMemo12, createSignal as createSignal9, For as For3, onMount as onMount9 } from "solid-js";

// src/grid/cells/showEditDetails.tsx
import { createMemo as createMemo10 } from "solid-js";

// src/grid/cells/popupEditorComp.tsx
import { PopupEditorWrapper } from "ag-grid-community";
import { onCleanup as onCleanup5, useContext as useContext7 } from "solid-js";
import { Portal } from "solid-js/web";
var PopupEditorComp = (props) => {
  const { context, popupService, localeService, gridOptionsService } = useContext7(BeansContext);
  const { editDetails, cellCtrl, eParentCell } = props;
  const { compDetails } = editDetails;
  const useModelPopup = gridOptionsService.get("stopEditingWhenCellsLoseFocus");
  const wrapper = context.createBean(new PopupEditorWrapper(compDetails.params));
  const ePopupGui = wrapper.getGui();
  const positionParams = {
    column: cellCtrl.getColumn(),
    rowNode: cellCtrl.getRowNode(),
    type: "popupCellEditor",
    eventSource: eParentCell,
    ePopup: ePopupGui,
    position: editDetails.popupPosition,
    keepWithinBounds: true
  };
  const positionCallback = popupService.positionPopupByComponent.bind(popupService, positionParams);
  const translate = localeService.getLocaleTextFunc();
  const addPopupRes = popupService.addPopup({
    modal: useModelPopup,
    eChild: ePopupGui,
    closeOnEsc: true,
    closedCallback: () => {
      cellCtrl.onPopupEditorClosed();
    },
    anchorToElement: eParentCell,
    positionCallback,
    ariaLabel: translate("ariaLabelCellEditor", "Cell Editor")
  });
  const hideEditorPopup = addPopupRes ? addPopupRes.hideFunc : void 0;
  onCleanup5(() => {
    if (hideEditorPopup != null) {
      hideEditorPopup();
    }
    context.destroyBean(wrapper);
  });
  return <Portal mount={ePopupGui}>{props.children}</Portal>;
};
var PopupEditorComp_default = PopupEditorComp;

// src/grid/cells/showEditDetails.tsx
var ShowEditDetails = (props) => {
  const getCompDetails = createMemo10(() => props.editDetails.compDetails);
  const compDetails = props.editDetails.compDetails;
  if (!compDetails) {
    return <></>;
  }
  const inPopup = props.editDetails.popup;
  const eGui = props.eGuiFn();
  return <>
      {inPopup && <PopupEditorComp_default
    cellCtrl={props.cellCtrl}
    eParentCell={eGui}
    editDetails={props.editDetails}
  >
          <UserComp_default compDetails={getCompDetails()} ref={props.setPopupRef} />
        </PopupEditorComp_default>}
      {!inPopup && <UserComp_default compDetails={getCompDetails()} ref={props.setInlineRef} />}
    </>;
};
var ShowEditDetails_default = ShowEditDetails;

// src/grid/cells/showRenderDetails.tsx
import { createMemo as createMemo11, onCleanup as onCleanup6, useContext as useContext8 } from "solid-js";
var ToolsComp = (props) => {
  const { context } = useContext8(BeansContext);
  const CompWrapper = (innerProps) => {
    const comp = innerProps.createFn();
    if (!comp) {
      return <></>;
    }
    onCleanup6(() => context.destroyBean(comp));
    return <>{comp.getGui()}</>;
  };
  return <>
      {props.includeSelection && <CompWrapper
    createFn={() => {
      const checkboxSelectionComp = props.cellCtrl.createSelectionCheckbox();
      props.setSelectionCheckboxId(checkboxSelectionComp.getCheckboxId());
      return checkboxSelectionComp;
    }}
  />}
      {props.includeDndSource && <CompWrapper createFn={() => props.cellCtrl.createDndSource()} />}
      {props.includeRowDrag && <CompWrapper createFn={() => props.cellCtrl.createRowDragComp()} />}
    </>;
};
var ShowRenderDetails = (props) => {
  const getCompDetails = createMemo11(() => props.showDetails.compDetails);
  const isNoCompDetails = createMemo11(() => props.showDetails.compDetails == null);
  const valueForNoCellRenderer = () => {
    const value = props.showDetails.value;
    return value && value.toString ? value.toString() : value;
  };
  const bodyJsxFunc = () => <>
      {isNoCompDetails() && <>{valueForNoCellRenderer()}</>}
      {getCompDetails() && <UserComp_default compDetails={getCompDetails()} ref={props.ref} />}
    </>;
  return <>
      {props.showTools && <ToolsComp
    includeDndSource={props.includeDndSource}
    includeRowDrag={props.includeRowDrag}
    includeSelection={props.includeSelection}
    setSelectionCheckboxId={props.setSelectionCheckboxId}
    cellCtrl={props.cellCtrl}
  />}
      {props.showCellWrapper ? <span
    role="presentation"
    id={`cell-${props.cellInstanceId}`}
    class="ag-cell-value"
    ref={props.setECellValue}
  >
          {bodyJsxFunc()}
        </span> : bodyJsxFunc()}
    </>;
};
var ShowRenderDetails_default = ShowRenderDetails;

// src/grid/cells/cellComp.tsx
var checkCellEditorDeprecations = (popup, cellEditor, cellCtrl) => {
  const col = cellCtrl.getColumn();
  if (!popup && cellEditor.isPopup && cellEditor.isPopup()) {
    const msg = `AG Grid: Found an issue in column ${col.getColId()}. If using SolidJS, specify an editor is a popup using colDef.cellEditorPopup=true. AG Grid SolidJS cannot depend on the editor component specifying if it's in a popup (via the isPopup() method on the editor), as SolidJS needs to know this information BEFORE the component is created.`;
    _3.doOnce(() => void 0, "jsEditorComp-isPopup-" + cellCtrl.getColumn().getColId());
  }
  if (popup && cellEditor.getPopupPosition && cellEditor.getPopupPosition() != null) {
    const msg = `AG Grid: Found an issue in column ${col.getColId()}. If using SolidJS, specify an editor popup position using colDef.cellEditorPopupPosition=true. AG Grid SolidJS cannot depend on the editor component specifying it's position (via the getPopupPosition() method on the editor), as SolidJS needs to know this information BEFORE the component is created.`;
    _3.doOnce(
      () => void 0,
      "jsEditorComp-getPopupPosition-" + cellCtrl.getColumn().getColId()
    );
  }
};
var CellComp = (props) => {
  const { cellCtrl, printLayout, editingRow } = props;
  const [renderDetails, setRenderDetails] = createSignal9();
  const [editDetails, setEditDetails] = createSignal9();
  let renderCompVersion = 0;
  const [renderCompVersionList, setRenderCompVersionList] = createSignal9([
    renderCompVersion
  ]);
  const [userStyles, setUserStyles] = createSignal9();
  const [tabIndex, setTabIndex] = createSignal9(cellCtrl.getTabIndex());
  const [colId, setColId] = createSignal9(cellCtrl.getColumnIdSanitised());
  const [selectionCheckboxId, setSelectionCheckboxId] = createSignal9();
  const [includeSelection, setIncludeSelection] = createSignal9(false);
  const [includeRowDrag, setIncludeRowDrag] = createSignal9(false);
  const [includeDndSource, setIncludeDndSource] = createSignal9(false);
  const forceWrapper = cellCtrl.isForceWrapper();
  let eCellWrapper;
  let eCellValue;
  const setECellValue = (val) => {
    eCellValue = val;
  };
  let eGui;
  let cellRenderer = null;
  let cellEditor = null;
  const setEditorRef = (popup, ref) => {
    cellEditor = ref;
    if (!cellEditor) {
      return;
    }
    checkCellEditorDeprecations(popup, cellEditor, cellCtrl);
    const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
    if (editingCancelledByUserComp) {
      setTimeout(() => {
        cellCtrl.stopEditing(true);
        cellCtrl.focusCell(true);
      });
    }
    const refAny = ref;
    if (refAny.afterGuiAttached) {
      setTimeout(() => refAny.afterGuiAttached(), 0);
    }
  };
  const setPopupEditorRef = (ref) => setEditorRef(true, ref);
  const setInlineEditorRef = (ref) => setEditorRef(false, ref);
  const cssClassManager = new CssClassManager2(() => eGui);
  const showTools = createMemo12(
    () => renderDetails() != null && (includeSelection() || includeDndSource() || includeRowDrag())
  );
  const showCellWrapper = createMemo12(() => forceWrapper || showTools());
  const cellInstanceId = cellCtrl.getInstanceId();
  onMount9(() => {
    if (!cellCtrl) {
      return;
    }
    const compProxy = {
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setUserStyles: (styles) => setUserStyles(styles),
      getFocusableElement: () => eGui,
      setIncludeSelection: (include) => setIncludeSelection(include),
      setIncludeRowDrag: (include) => setIncludeRowDrag(include),
      setIncludeDndSource: (include) => setIncludeDndSource(include),
      getCellEditor: () => cellEditor,
      getCellRenderer: () => cellRenderer ? cellRenderer : null,
      getParentOfValue: () => eCellValue ? eCellValue : eCellWrapper ? eCellWrapper : eGui,
      setRenderDetails: (compDetails, value, force) => {
        setRenderDetails({
          value,
          compDetails,
          force
        });
      },
      setEditDetails: (compDetails, popup, popupPosition) => {
        if (compDetails) {
          setEditDetails({
            compDetails,
            popup,
            popupPosition
          });
          if (!popup) {
            setRenderDetails(void 0);
          }
        } else {
          setEditDetails(void 0);
        }
      }
    };
    cellCtrl.setComp(compProxy, eGui, eCellWrapper, printLayout, editingRow);
  });
  createEffect3(() => {
    const isEditing = !!editDetails();
    const isPopup = isEditing && !!editDetails()?.popup;
    cssClassManager.addOrRemoveCssClass("ag-cell-value", !showCellWrapper());
    cssClassManager.addOrRemoveCssClass("ag-cell-inline-editing", isEditing && !isPopup);
    cssClassManager.addOrRemoveCssClass("ag-cell-popup-editing", isEditing && isPopup);
    cssClassManager.addOrRemoveCssClass("ag-cell-not-inline-editing", !isEditing || isPopup);
    cellCtrl.getRowCtrl()?.setInlineEditingCss(isEditing);
  });
  let readyForRefresh = false;
  createEffect3(() => {
    const details = renderDetails();
    const isJsCellRenderer = details != null && details.compDetails != null && !details.compDetails.componentFromFramework;
    if (!isJsCellRenderer) {
      readyForRefresh = false;
      return;
    }
    if (!readyForRefresh) {
      readyForRefresh = true;
      return;
    }
    if (!cellRenderer) {
      return;
    }
    const params = details.compDetails.params;
    const result = cellRenderer.refresh ? cellRenderer.refresh(params) : false;
    if (result != true) {
      renderCompVersion++;
      setRenderCompVersionList([renderCompVersion]);
    }
  });
  const eGuiFn = () => eGui;
  const bodyJsxFunc = () => <>
      <For3 each={renderCompVersionList()}>
        {() => <>
            {renderDetails() && <ShowRenderDetails_default
    showDetails={renderDetails()}
    ref={cellRenderer}
    cellInstanceId={cellInstanceId}
    showCellWrapper={showCellWrapper()}
    cellCtrl={cellCtrl}
    includeDndSource={includeDndSource()}
    includeRowDrag={includeRowDrag()}
    includeSelection={includeSelection()}
    setSelectionCheckboxId={setSelectionCheckboxId}
    showTools={showTools()}
    setECellValue={setECellValue}
  />}
          </>}
      </For3>
      {editDetails() && <ShowEditDetails_default
    editDetails={editDetails()}
    cellCtrl={cellCtrl}
    eGuiFn={eGuiFn}
    setInlineRef={setInlineEditorRef}
    setPopupRef={setPopupEditorRef}
  />}
    </>;
  return <div
    ref={eGui}
    style={userStyles()}
    tabIndex={tabIndex()}
    role={cellCtrl.getCellAriaRole()}
    col-id={colId()}
  >
      {" "}
      {showCellWrapper() ? <div class="ag-cell-wrapper" role="presentation" ref={eCellWrapper}>
          {bodyJsxFunc()}
        </div> : bodyJsxFunc()}
    </div>;
};
var CellComp_default = CellComp;

// src/grid/rows/rowComp.tsx
var maintainOrderOnColumns = (prev, next, domOrder) => {
  if (domOrder) {
    const res2 = { list: next, instanceIdMap: /* @__PURE__ */ new Map() };
    next.forEach((c) => res2.instanceIdMap.set(c.getInstanceId(), c));
    return res2;
  }
  const oldCellCtrls = [];
  const newCellCtrls = [];
  const newInstanceIdMap = /* @__PURE__ */ new Map();
  const tempMap = /* @__PURE__ */ new Map();
  next.forEach((c) => tempMap.set(c.getInstanceId(), c));
  prev.list.forEach((c) => {
    const instanceId = c.getInstanceId();
    if (tempMap.has(instanceId)) {
      oldCellCtrls.push(c);
      newInstanceIdMap.set(instanceId, c);
    }
  });
  next.forEach((c) => {
    const instanceId = c.getInstanceId();
    if (!prev.instanceIdMap.has(instanceId)) {
      newCellCtrls.push(c);
      newInstanceIdMap.set(instanceId, c);
    }
  });
  const res = {
    list: [...oldCellCtrls, ...newCellCtrls],
    instanceIdMap: newInstanceIdMap
  };
  return res;
};
var RowComp = (params) => {
  const { rowCtrl, containerType } = params;
  const [getRowIndex, setRowIndex] = createSignal10();
  const [getRowId, setRowId] = createSignal10();
  const [getRowBusinessKey, setRowBusinessKey] = createSignal10();
  const [getTabIndex, setTabIndex] = createSignal10(rowCtrl.getTabIndex());
  const [getUserStyles, setUserStyles] = createSignal10();
  const [getCellCtrls, setCellCtrls] = createSignal10({
    list: [],
    instanceIdMap: /* @__PURE__ */ new Map()
  });
  const [getFullWidthCompDetails, setFullWidthCompDetails] = createSignal10();
  const [getDomOrder, setDomOrder] = createSignal10(false);
  const [getTop, setTop] = createSignal10(
    rowCtrl.getInitialRowTop(containerType)
  );
  const [getTransform, setTransform] = createSignal10(
    rowCtrl.getInitialTransform(containerType)
  );
  let eGui;
  let fullWidthCompRef;
  const setFullWidthRef = (newRef) => {
    fullWidthCompRef = newRef;
  };
  createEffect4(() => {
    const compDetails = getFullWidthCompDetails();
    if (!compDetails) {
      return;
    }
    let tryCount = 0;
    const trySetup = () => {
      const eChild = eGui.firstChild;
      if (eChild) {
        rowCtrl.setupDetailRowAutoHeight(eChild);
        return;
      }
      if (tryCount >= 10) {
        return;
      }
      tryCount++;
      setTimeout(trySetup, 0);
    };
    trySetup();
  });
  onMount10(() => {
    if (!rowCtrl.isAlive()) {
      return;
    }
    const cssClassManager = new CssClassManager3(() => eGui);
    const compProxy = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: (value) => setTop(value),
      setTransform: (value) => setTransform(value),
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (name, on) => cssClassManager.addOrRemoveCssClass(name, on),
      setDomOrder: (domOrder) => setDomOrder(domOrder),
      setRowIndex: (value) => setRowIndex(value),
      setRowId: (value) => setRowId(value),
      setRowBusinessKey: (value) => setRowBusinessKey(value),
      setUserStyles: (styles) => setUserStyles(styles),
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (next) => setCellCtrls(maintainOrderOnColumns(getCellCtrls(), next, getDomOrder())),
      showFullWidth: (compDetails) => setFullWidthCompDetails(compDetails),
      getFullWidthCellRenderer: () => fullWidthCompRef,
      refreshFullWidth: (getUpdatedParams) => {
        if (!fullWidthCompRef || !fullWidthCompRef.refresh) {
          return false;
        }
        return fullWidthCompRef.refresh(getUpdatedParams());
      }
    };
    rowCtrl.setComp(compProxy, eGui, containerType);
    onCleanup7(() => rowCtrl.unsetComp(containerType));
  });
  const getRowStyles = createMemo13(() => {
    const res = {
      top: getTop(),
      transform: getTransform()
    };
    Object.assign(res, getUserStyles());
    return res;
  });
  const isShowCells = createMemo13(() => getCellCtrls() != null);
  const isShowFullWidth = createMemo13(() => getFullWidthCompDetails() != null);
  const showCellsJsx = () => <For4 each={getCellCtrls().list}>
      {(cellCtrl) => <CellComp_default
    cellCtrl={cellCtrl}
    editingRow={rowCtrl.isEditing()}
    printLayout={rowCtrl.isPrintLayout()}
  />}
    </For4>;
  const showFullWidthJsx = () => <UserComp_default compDetails={getFullWidthCompDetails()} ref={setFullWidthRef} />;
  return <div
    ref={eGui}
    role="row"
    style={getRowStyles()}
    row-index={getRowIndex()}
    row-id={getRowId()}
    row-business-key={getRowBusinessKey()}
    tabIndex={getTabIndex()}
  >
      {isShowFullWidth() && showFullWidthJsx()}
      {isShowCells() && showCellsJsx()}
    </div>;
};
var RowComp_default = RowComp;

// src/grid/rows/rowContainerComp.tsx
var RowContainerComp = (props) => {
  const { context } = useContext9(BeansContext);
  const [viewportHeight, setViewportHeight] = createSignal11("");
  const [rowCtrlsOrdered, setRowCtrlsOrdered] = createSignal11([]);
  const [rowCtrls, setRowCtrls] = createSignal11([]);
  const [domOrder, setDomOrder] = createSignal11(false);
  const { name } = props;
  const containerType = createMemo14(() => getRowContainerTypeForName(name));
  let eViewport;
  let eContainer;
  const cssClasses = createMemo14(() => RowContainerCtrl.getRowContainerCssClasses(name));
  const viewportClasses = createMemo14(() => classesList(cssClasses().viewport));
  const containerClasses = createMemo14(() => classesList(cssClasses().container));
  const centerTemplate = name === RowContainerName.CENTER || name === RowContainerName.TOP_CENTER || name === RowContainerName.BOTTOM_CENTER || name === RowContainerName.STICKY_TOP_CENTER;
  let rowCtrlsOrderedCopy = [];
  createEffect5(() => {
    if (domOrder()) {
      setRowCtrlsOrdered(rowCtrls());
      return;
    }
    const prev = rowCtrlsOrderedCopy;
    const oldRows = prev.filter((r) => rowCtrls().indexOf(r) >= 0);
    const newRows = rowCtrls().filter((r) => oldRows.indexOf(r) < 0);
    const next = [...oldRows, ...newRows];
    setRowCtrlsOrdered(next);
    rowCtrlsOrderedCopy = next;
  });
  onMount11(() => {
    const compProxy = {
      setViewportHeight,
      setRowCtrls: ({ rowCtrls: rowCtrls2 }) => setRowCtrls(rowCtrls2),
      setDomOrder: (domOrder2) => setDomOrder(domOrder2),
      setContainerWidth: (width) => {
        if (eContainer) {
          eContainer.style.width = width;
        }
      }
    };
    const ctrl = context.createBean(new RowContainerCtrl(name));
    onCleanup8(() => context.destroyBean(ctrl));
    ctrl.setComp(compProxy, eContainer, eViewport);
  });
  const viewportStyle = createMemo14(() => ({
    height: viewportHeight()
  }));
  const buildContainer = () => <div class={containerClasses()} ref={eContainer} role={"rowgroup"}>
      <For5 each={rowCtrlsOrdered()}>
        {(rowCtrl, i) => <RowComp_default rowCtrl={rowCtrl} containerType={containerType()} />}
      </For5>
    </div>;
  return <>
      {centerTemplate ? <div class={viewportClasses()} ref={eViewport} role="presentation" style={viewportStyle()}>
          {buildContainer()}
        </div> : buildContainer()}
    </>;
};
var RowContainerComp_default = RowContainerComp;

// src/grid/gridBodyComp.tsx
var GridBodyComp = () => {
  const { context, agStackComponentsRegistry, resizeObserverService } = useContext10(BeansContext);
  const [getRowAnimationClass, setRowAnimationClass] = createSignal12("");
  const [getAriaColCount, setAriaColCount] = createSignal12(0);
  const [getAriaRowCount, setAriaRowCount] = createSignal12(0);
  const [getTopHeight, setTopHeight] = createSignal12(0);
  const [getBottomHeight, setBottomHeight] = createSignal12(0);
  const [getStickyTopHeight, setStickyTopHeight] = createSignal12("0px");
  const [getStickyTopTop, setStickyTopTop] = createSignal12("0px");
  const [getStickyTopWidth, setStickyTopWidth] = createSignal12("100%");
  const [getTopDisplay, setTopDisplay] = createSignal12("");
  const [getBottomDisplay, setBottomDisplay] = createSignal12("");
  const [getBodyViewportWidth, setBodyViewportWidth] = createSignal12("");
  const [getMovingCss, setMovingCss] = createSignal12(null);
  const [getForceVerticalScrollClass, setForceVerticalScrollClass] = createSignal12(
    null
  );
  const [getTopAndBottomOverflowY, setTopAndBottomOverflowY] = createSignal12(null);
  const [getCellSelectableCss, setCellSelectableCss] = createSignal12(null);
  const [getLayoutClass, setLayoutClass] = createSignal12("ag-layout-normal");
  let eRoot;
  let eTop;
  let eStickyTop;
  let eBody;
  let eBodyViewport;
  let eBottom;
  const destroyFuncs = [];
  onCleanup9(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  onMount12(() => {
    if (!context) {
      return;
    }
    const newComp = (tag) => {
      const CompClass = agStackComponentsRegistry.getComponentClass(tag);
      const comp = context.createBean(new CompClass());
      onCleanup9(() => context.destroyBean(comp));
      return comp;
    };
    eRoot.appendChild(newComp("AG-FAKE-HORIZONTAL-SCROLL").getGui());
    eRoot.appendChild(newComp("AG-OVERLAY-WRAPPER").getGui());
    eBody.appendChild(newComp("AG-FAKE-VERTICAL-SCROLL").getGui());
    const compProxy = {
      setRowAnimationCssOnBodyViewport: setRowAnimationClass,
      setColumnCount: setAriaColCount,
      setRowCount: setAriaRowCount,
      setTopHeight,
      setBottomHeight,
      setStickyTopHeight,
      setStickyTopTop,
      setStickyTopWidth,
      setTopDisplay,
      setBottomDisplay,
      setColumnMovingCss: setMovingCss,
      updateLayoutClasses: setLayoutClass,
      setAlwaysVerticalScrollClass: setForceVerticalScrollClass,
      setPinnedTopBottomOverflowY: setTopAndBottomOverflowY,
      setCellSelectableCss: (cssClass, flag) => setCellSelectableCss(flag ? cssClass : null),
      setBodyViewportWidth,
      registerBodyViewportResizeListener: (listener) => {
        const unsubscribeFromResize = resizeObserverService.observeResize(eBodyViewport, listener);
        destroyFuncs.push(() => unsubscribeFromResize());
      }
    };
    const ctrl = context.createBean(new GridBodyCtrl());
    onCleanup9(() => context.destroyBean(ctrl));
    setTimeout(() => ctrl.setComp(compProxy, eRoot, eBodyViewport, eTop, eBottom, eStickyTop), 0);
  });
  const getRootClasses = createMemo15(
    () => classesList("ag-root", "ag-unselectable", getMovingCss(), getLayoutClass())
  );
  const getBodyClasses = createMemo15(() => classesList("ag-body", getLayoutClass()));
  const getBodyViewportClasses = createMemo15(
    () => classesList(
      "ag-body-viewport",
      getRowAnimationClass(),
      getLayoutClass(),
      getForceVerticalScrollClass(),
      getCellSelectableCss()
    )
  );
  const getTopClasses = createMemo15(() => classesList("ag-floating-top", getCellSelectableCss()));
  const getStickyTopClasses = createMemo15(
    () => classesList("ag-sticky-top", getCellSelectableCss())
  );
  const getBottomClasses = createMemo15(
    () => classesList("ag-floating-bottom", getCellSelectableCss())
  );
  const getTopStyle = createMemo15(() => ({
    height: `${getTopHeight()}px`,
    "min-height": `${getTopHeight()}px`,
    display: getTopDisplay(),
    "overflow-y": getTopAndBottomOverflowY()
  }));
  const getStickyTopStyle = createMemo15(() => ({
    height: getStickyTopHeight(),
    top: getStickyTopTop(),
    width: getStickyTopWidth()
  }));
  const getBottomStyle = createMemo15(() => ({
    height: `${getBottomHeight()}px`,
    "min-height": `${getBottomHeight()}px`,
    display: getBottomDisplay(),
    "overflow-y": getTopAndBottomOverflowY()
  }));
  const getBodyViewportStyle = createMemo15(() => ({
    width: getBodyViewportWidth()
  }));
  return <div
    ref={eRoot}
    class={getRootClasses()}
    role="treegrid"
    aria-colcount={getAriaColCount()}
    aria-rowcount={getAriaRowCount()}
  >
      <GridHeaderComp_default />
      <div ref={eTop} class={getTopClasses()} role="presentation" style={getTopStyle()}>
        <RowContainerComp_default name={RowContainerName2.TOP_LEFT} />
        <RowContainerComp_default name={RowContainerName2.TOP_CENTER} />
        <RowContainerComp_default name={RowContainerName2.TOP_RIGHT} />
        <RowContainerComp_default name={RowContainerName2.TOP_FULL_WIDTH} />
      </div>
      <div class={getBodyClasses()} ref={eBody} role="presentation">
        <div
    ref={eBodyViewport}
    class={getBodyViewportClasses()}
    role="presentation"
    style={getBodyViewportStyle()}
  >
          <RowContainerComp_default name={RowContainerName2.LEFT} />
          <RowContainerComp_default name={RowContainerName2.CENTER} />
          <RowContainerComp_default name={RowContainerName2.RIGHT} />
          <RowContainerComp_default name={RowContainerName2.FULL_WIDTH} />
        </div>
      </div>
      <div
    ref={eStickyTop}
    class={getStickyTopClasses()}
    role="presentation"
    style={getStickyTopStyle()}
  >
        <RowContainerComp_default name={RowContainerName2.STICKY_TOP_LEFT} />
        <RowContainerComp_default name={RowContainerName2.STICKY_TOP_CENTER} />
        <RowContainerComp_default name={RowContainerName2.STICKY_TOP_RIGHT} />
        <RowContainerComp_default name={RowContainerName2.STICKY_TOP_FULL_WIDTH} />
      </div>
      <div ref={eBottom} class={getBottomClasses()} role="presentation" style={getBottomStyle()}>
        <RowContainerComp_default name={RowContainerName2.BOTTOM_LEFT} />
        <RowContainerComp_default name={RowContainerName2.BOTTOM_CENTER} />
        <RowContainerComp_default name={RowContainerName2.BOTTOM_RIGHT} />
        <RowContainerComp_default name={RowContainerName2.BOTTOM_FULL_WIDTH} />
      </div>
    </div>;
};
var GridBodyComp_default = GridBodyComp;

// src/grid/tabGuardComp.tsx
import { TabGuardClassNames, TabGuardCtrl } from "ag-grid-community";
import { createSignal as createSignal13, onCleanup as onCleanup10, onMount as onMount13, useContext as useContext11 } from "solid-js";
var TabGuardComp = (props) => {
  const {
    children,
    eFocusableElement,
    onTabKeyDown,
    gridCtrl,
    forceFocusOutWhenTabGuardsAreEmpty
  } = props;
  const [tabIndex, setTabIndex] = createSignal13();
  let eTopGuard;
  let eBottomGuard;
  let ctrl;
  const { context } = useContext11(BeansContext);
  onMount13(() => {
    const compProxy = {
      setTabIndex: (value) => value == null ? setTabIndex(void 0) : setTabIndex(parseInt(value, 10))
    };
    ctrl = context.createBean(
      new TabGuardCtrl({
        comp: compProxy,
        eTopGuard,
        eBottomGuard,
        eFocusableElement,
        onTabKeyDown,
        forceFocusOutWhenTabGuardsAreEmpty,
        focusInnerElement: (fromBottom) => gridCtrl.focusInnerElement(fromBottom)
      })
    );
    props.ref({
      forceFocusOutOfContainer(up) {
        ctrl.forceFocusOutOfContainer(up);
      }
    });
  });
  onCleanup10(() => context.destroyBean(ctrl));
  return <>
      <div
    class={`${TabGuardClassNames.TAB_GUARD} ${TabGuardClassNames.TAB_GUARD_TOP}`}
    role="presentation"
    tabIndex={tabIndex()}
    ref={eTopGuard}
  />

      {children}

      <div
    class={`${TabGuardClassNames.TAB_GUARD} ${TabGuardClassNames.TAB_GUARD_BOTTOM}`}
    role="presentation"
    tabIndex={tabIndex()}
    ref={eBottomGuard}
  />
    </>;
};
var TabGuardComp_default = TabGuardComp;

// src/grid/gridComp.tsx
var GridComp = (props) => {
  const [rtlClass, setRtlClass] = createSignal14("");
  const [keyboardFocusClass, setKeyboardFocusClass] = createSignal14("");
  const [layoutClass, setLayoutClass] = createSignal14("");
  const [cursor, setCursor] = createSignal14(null);
  const [userSelect, setUserSelect] = createSignal14(null);
  const [initialised, setInitialised] = createSignal14(false);
  const { context } = props;
  const beans = context.getBean("beans");
  let tabGuardRef;
  const setTabGuardRef = (newRef) => {
    tabGuardRef = newRef;
    tabGuardRef && tabGuardReady();
  };
  let eGui;
  let eBody;
  let gridCtrl;
  const onTabKeyDown = () => void 0;
  const destroyFuncs = [];
  onCleanup11(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  const tabGuardReady = () => {
    const beansToDestroy = [];
    const { agStackComponentsRegistry } = beans;
    const HeaderDropZonesClass = agStackComponentsRegistry.getComponentClass(
      "AG-GRID-HEADER-DROP-ZONES"
    );
    const SideBarClass = agStackComponentsRegistry.getComponentClass("AG-SIDE-BAR");
    const StatusBarClass = agStackComponentsRegistry.getComponentClass("AG-STATUS-BAR");
    const WatermarkClass = agStackComponentsRegistry.getComponentClass("AG-WATERMARK");
    const PaginationClass = agStackComponentsRegistry.getComponentClass("AG-PAGINATION");
    const additionalEls = [];
    if (gridCtrl.showDropZones() && HeaderDropZonesClass) {
      const headerDropZonesComp = context.createBean(new HeaderDropZonesClass());
      const el = headerDropZonesComp.getGui();
      eGui.insertAdjacentElement("afterbegin", el);
      additionalEls.push(el);
      beansToDestroy.push(headerDropZonesComp);
    }
    if (gridCtrl.showSideBar() && SideBarClass) {
      const sideBarComp = context.createBean(new SideBarClass());
      const el = sideBarComp.getGui();
      const bottomTabGuard = eBody.querySelector(".ag-tab-guard-bottom");
      if (bottomTabGuard) {
        bottomTabGuard.insertAdjacentElement("beforebegin", el);
        additionalEls.push(el);
      }
      beansToDestroy.push(sideBarComp);
    }
    if (gridCtrl.showStatusBar() && StatusBarClass) {
      const statusBarComp = context.createBean(new StatusBarClass());
      const el = statusBarComp.getGui();
      eGui.insertAdjacentElement("beforeend", el);
      additionalEls.push(el);
      beansToDestroy.push(statusBarComp);
    }
    if (PaginationClass) {
      const paginationComp = context.createBean(new PaginationClass());
      const el = paginationComp.getGui();
      eGui.insertAdjacentElement("beforeend", el);
      additionalEls.push(el);
      beansToDestroy.push(paginationComp);
    }
    if (gridCtrl.showWatermark() && WatermarkClass) {
      const watermarkComp = context.createBean(new WatermarkClass());
      const el = watermarkComp.getGui();
      eGui.insertAdjacentElement("beforeend", el);
      additionalEls.push(el);
      beansToDestroy.push(watermarkComp);
    }
    destroyFuncs.push(() => {
      context.destroyBeans(beansToDestroy);
      additionalEls.forEach((el) => {
        if (el.parentElement) {
          el.parentElement.removeChild(el);
        }
      });
    });
  };
  onMount14(() => {
    gridCtrl = context.createBean(new GridCtrl2());
    destroyFuncs.push(() => context.destroyBean(gridCtrl));
    const compProxy = {
      destroyGridUi: () => {
      },
      // do nothing, as framework users destroy grid by removing the comp
      setRtlClass,
      forceFocusOutOfContainer: (up) => {
        tabGuardRef && tabGuardRef.forceFocusOutOfContainer(up);
      },
      updateLayoutClasses: setLayoutClass,
      getFocusableContainers: () => {
        const els = [];
        const gridBodyCompEl = eGui.querySelector(".ag-root");
        const sideBarEl = eGui.querySelector(".ag-side-bar:not(.ag-hidden)");
        if (gridBodyCompEl) {
          els.push(gridBodyCompEl);
        }
        if (sideBarEl) {
          els.push(sideBarEl);
        }
        return els;
      },
      setCursor,
      setUserSelect
    };
    gridCtrl.setComp(compProxy, eGui, eGui);
    setInitialised(true);
  });
  const cssClasses = createMemo16(
    () => classesList("ag-root-wrapper", rtlClass(), keyboardFocusClass(), layoutClass(), props.class)
  );
  const bodyCssClasses = createMemo16(
    () => classesList("ag-root-wrapper-body", "ag-focus-managed", layoutClass())
  );
  const topStyle = createMemo16(() => ({
    userSelect: userSelect != null ? userSelect() : "",
    WebkitUserSelect: userSelect != null ? userSelect() : "",
    cursor: cursor != null ? cursor() : ""
  }));
  return <div ref={eGui} class={cssClasses()} style={topStyle()}>
      <div class={bodyCssClasses()} ref={eBody}>
        {initialised() && // we wait for initialised before rending the children, so GridComp has created and registered with it's
  // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
  // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
  // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
  // hangs the UI)
  <BeansContext.Provider value={beans}>
            <TabGuardComp_default
    ref={setTabGuardRef}
    eFocusableElement={eGui}
    onTabKeyDown={onTabKeyDown}
    gridCtrl={gridCtrl}
    forceFocusOutWhenTabGuardsAreEmpty={true}
  >
              <GridBodyComp_default />
            </TabGuardComp_default>
          </BeansContext.Provider>}
      </div>
    </div>;
};
var GridComp_default = GridComp;

// src/grid/agGridSolid.tsx
var AgGridSolid = function(props) {
  let eGui;
  let api;
  const [context, setContext] = createSignal15();
  const [getPortals, setPortals] = createSignal15([]);
  const destroyFuncs = [];
  onCleanup12(() => {
    destroyFuncs.forEach((f) => f());
    destroyFuncs.length = 0;
  });
  const propsCopy = {};
  Object.keys(props).forEach((key) => propsCopy[key] = props[key]);
  createEffect6(() => {
    const keys = Object.keys(props);
    const changes = {};
    let changesExist = false;
    keys.forEach((key) => {
      const currentValue = props[key];
      const previousValue = propsCopy[key];
      if (previousValue !== currentValue) {
        changes[key] = currentValue;
        propsCopy[key] = currentValue;
        changesExist = true;
      }
    });
    if (changesExist) {
      ComponentUtil.processOnChange(changes, api);
    }
  });
  onMount15(() => {
    const modules = props.modules || [];
    const portalManager = {
      addPortal: (info) => {
        setPortals([...getPortals(), info]);
      },
      removePortal: (info) => {
        setPortals(getPortals().filter((item) => item != info));
      }
    };
    const gridParams = {
      providedBeanInstances: {
        frameworkComponentWrapper: new SolidCompWrapperFactory(portalManager)
      },
      modules,
      frameworkOverrides: new SolidFrameworkOverrides()
    };
    const gridOptions = ComponentUtil.combineAttributesAndGridOptions(
      props.gridOptions,
      props
    );
    const createUiCallback = (context2) => {
      setContext(context2);
      const ctrlsService = context2.getBean(CtrlsService.NAME);
      ctrlsService.whenReady(() => {
        const refCallback = props.ref && props.ref;
        if (refCallback) {
          const gridRef = {
            api,
            columnApi: new ColumnApi(api)
          };
          refCallback(gridRef);
        }
        destroyFuncs.push(() => api.destroy());
      });
    };
    const acceptChangesCallback = () => {
    };
    const gridCoreCreator = new GridCoreCreator();
    api = gridCoreCreator.create(
      // @ts-ignore
      eGui,
      gridOptions,
      createUiCallback,
      acceptChangesCallback,
      gridParams
    );
  });
  return <div ref={eGui} style={{ height: "100%" }}>
      {context() && <GridComp_default class={props.class} context={context()} />}
      <For6 each={getPortals()}>
        {(info, i) => <Portal2 mount={info.mount}>
            <info.SolidClass {...info.props} ref={info.ref} />
          </Portal2>}
      </For6>
    </div>;
};
var AgGridSolid_default = AgGridSolid;

// src/index.tsx
var src_default = AgGridSolid_default;
export {
  src_default as default
};
